/* moonshot-identity-management-view.c generated by valac 0.10.4, the Vala compiler
 * generated from moonshot-identity-management-view.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <gdk/gdk.h>
#include <gee.h>
#include <glib/gi18n-lib.h>
#include <pango/pango.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <atk/atk.h>


#define TYPE_IDENTITY_MANAGER_VIEW (identity_manager_view_get_type ())
#define IDENTITY_MANAGER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDENTITY_MANAGER_VIEW, IdentityManagerView))
#define IDENTITY_MANAGER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDENTITY_MANAGER_VIEW, IdentityManagerViewClass))
#define IS_IDENTITY_MANAGER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDENTITY_MANAGER_VIEW))
#define IS_IDENTITY_MANAGER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDENTITY_MANAGER_VIEW))
#define IDENTITY_MANAGER_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDENTITY_MANAGER_VIEW, IdentityManagerViewClass))

typedef struct _IdentityManagerView IdentityManagerView;
typedef struct _IdentityManagerViewClass IdentityManagerViewClass;
typedef struct _IdentityManagerViewPrivate IdentityManagerViewPrivate;

#define TYPE_IDENTITY_MANAGER_APP (identity_manager_app_get_type ())
#define IDENTITY_MANAGER_APP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDENTITY_MANAGER_APP, IdentityManagerApp))
#define IDENTITY_MANAGER_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDENTITY_MANAGER_APP, IdentityManagerAppClass))
#define IS_IDENTITY_MANAGER_APP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDENTITY_MANAGER_APP))
#define IS_IDENTITY_MANAGER_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDENTITY_MANAGER_APP))
#define IDENTITY_MANAGER_APP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDENTITY_MANAGER_APP, IdentityManagerAppClass))

typedef struct _IdentityManagerApp IdentityManagerApp;
typedef struct _IdentityManagerAppClass IdentityManagerAppClass;

#define TYPE_IDENTITY_MANAGER_MODEL (identity_manager_model_get_type ())
#define IDENTITY_MANAGER_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDENTITY_MANAGER_MODEL, IdentityManagerModel))
#define IDENTITY_MANAGER_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDENTITY_MANAGER_MODEL, IdentityManagerModelClass))
#define IS_IDENTITY_MANAGER_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDENTITY_MANAGER_MODEL))
#define IS_IDENTITY_MANAGER_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDENTITY_MANAGER_MODEL))
#define IDENTITY_MANAGER_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDENTITY_MANAGER_MODEL, IdentityManagerModelClass))

typedef struct _IdentityManagerModel IdentityManagerModel;
typedef struct _IdentityManagerModelClass IdentityManagerModelClass;

#define TYPE_IDENTITY_REQUEST (identity_request_get_type ())
#define IDENTITY_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDENTITY_REQUEST, IdentityRequest))
#define IDENTITY_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDENTITY_REQUEST, IdentityRequestClass))
#define IS_IDENTITY_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDENTITY_REQUEST))
#define IS_IDENTITY_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDENTITY_REQUEST))
#define IDENTITY_REQUEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDENTITY_REQUEST, IdentityRequestClass))

typedef struct _IdentityRequest IdentityRequest;
typedef struct _IdentityRequestClass IdentityRequestClass;

#define TYPE_CUSTOM_VBOX (custom_vbox_get_type ())
#define CUSTOM_VBOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOM_VBOX, CustomVBox))
#define CUSTOM_VBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOM_VBOX, CustomVBoxClass))
#define IS_CUSTOM_VBOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOM_VBOX))
#define IS_CUSTOM_VBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOM_VBOX))
#define CUSTOM_VBOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOM_VBOX, CustomVBoxClass))

typedef struct _CustomVBox CustomVBox;
typedef struct _CustomVBoxClass CustomVBoxClass;

#define TYPE_ID_CARD (id_card_get_type ())
#define ID_CARD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ID_CARD, IdCard))
#define ID_CARD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ID_CARD, IdCardClass))
#define IS_ID_CARD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ID_CARD))
#define IS_ID_CARD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ID_CARD))
#define ID_CARD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ID_CARD, IdCardClass))

typedef struct _IdCard IdCard;
typedef struct _IdCardClass IdCardClass;

#define IDENTITY_MANAGER_VIEW_TYPE_COLUMNS (identity_manager_view_columns_get_type ())
#define _identity_manager_app_unref0(var) ((var == NULL) ? NULL : (var = (identity_manager_app_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_slist_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_slist_free_g_object_unref (var), NULL)))
#define _g_queue_free0(var) ((var == NULL) ? NULL : (var = (g_queue_free (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
typedef struct _IdentityManagerAppPrivate IdentityManagerAppPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_ID_CARD_WIDGET (id_card_widget_get_type ())
#define ID_CARD_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ID_CARD_WIDGET, IdCardWidget))
#define ID_CARD_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ID_CARD_WIDGET, IdCardWidgetClass))
#define IS_ID_CARD_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ID_CARD_WIDGET))
#define IS_ID_CARD_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ID_CARD_WIDGET))
#define ID_CARD_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ID_CARD_WIDGET, IdCardWidgetClass))

typedef struct _IdCardWidget IdCardWidget;
typedef struct _IdCardWidgetClass IdCardWidgetClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

#define TYPE_ADD_IDENTITY_DIALOG (add_identity_dialog_get_type ())
#define ADD_IDENTITY_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ADD_IDENTITY_DIALOG, AddIdentityDialog))
#define ADD_IDENTITY_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ADD_IDENTITY_DIALOG, AddIdentityDialogClass))
#define IS_ADD_IDENTITY_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ADD_IDENTITY_DIALOG))
#define IS_ADD_IDENTITY_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ADD_IDENTITY_DIALOG))
#define ADD_IDENTITY_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ADD_IDENTITY_DIALOG, AddIdentityDialogClass))

typedef struct _AddIdentityDialog AddIdentityDialog;
typedef struct _AddIdentityDialogClass AddIdentityDialogClass;
typedef struct _IdentityRequestPrivate IdentityRequestPrivate;
#define __g_slist_free_g_free0(var) ((var == NULL) ? NULL : (var = (_g_slist_free_g_free (var), NULL)))

#define TYPE_RULE (rule_get_type ())
typedef struct _Rule Rule;
typedef struct _Block1Data Block1Data;
#define _g_pattern_spec_free0(var) ((var == NULL) ? NULL : (var = (g_pattern_spec_free (var), NULL)))

#define TYPE_ADD_PASSWORD_DIALOG (add_password_dialog_get_type ())
#define ADD_PASSWORD_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ADD_PASSWORD_DIALOG, AddPasswordDialog))
#define ADD_PASSWORD_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ADD_PASSWORD_DIALOG, AddPasswordDialogClass))
#define IS_ADD_PASSWORD_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ADD_PASSWORD_DIALOG))
#define IS_ADD_PASSWORD_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ADD_PASSWORD_DIALOG))
#define ADD_PASSWORD_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ADD_PASSWORD_DIALOG, AddPasswordDialogClass))

typedef struct _AddPasswordDialog AddPasswordDialog;
typedef struct _AddPasswordDialogClass AddPasswordDialogClass;
#define _pango_font_description_free0(var) ((var == NULL) ? NULL : (var = (pango_font_description_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _IdentityManagerView {
	GtkWindow parent_instance;
	IdentityManagerViewPrivate * priv;
	IdentityManagerApp* parent_app;
	IdentityManagerModel* identities_manager;
	GQueue* request_queue;
};

struct _IdentityManagerViewClass {
	GtkWindowClass parent_class;
};

struct _IdentityManagerViewPrivate {
	GtkUIManager* ui_manager;
	GtkEntry* search_entry;
	GtkVBox* vbox_right;
	CustomVBox* custom_vbox;
	GtkVBox* services_internal_vbox;
	GtkEntry* username_entry;
	GtkEntry* password_entry;
	GtkListStore* listmodel;
	GtkTreeModelFilter* filter;
	GSList* candidates;
	IdCard* default_id_card;
	GHashTable* service_button_map;
};

typedef enum  {
	IDENTITY_MANAGER_VIEW_COLUMNS_IDCARD_COL,
	IDENTITY_MANAGER_VIEW_COLUMNS_LOGO_COL,
	IDENTITY_MANAGER_VIEW_COLUMNS_ISSUER_COL,
	IDENTITY_MANAGER_VIEW_COLUMNS_USERNAME_COL,
	IDENTITY_MANAGER_VIEW_COLUMNS_PASSWORD_COL,
	IDENTITY_MANAGER_VIEW_COLUMNS_N_COLUMNS
} IdentityManagerViewColumns;

struct _IdentityManagerApp {
	GTypeInstance parent_instance;
	volatile int ref_count;
	IdentityManagerAppPrivate * priv;
	IdentityManagerModel* model;
};

struct _IdentityManagerAppClass {
	GTypeClass parent_class;
	void (*finalize) (IdentityManagerApp *self);
};

struct _IdentityRequest {
	GObject parent_instance;
	IdentityRequestPrivate * priv;
	IdCard* id_card;
	gboolean complete;
	gboolean select_default;
	char* nai;
	char* password;
	char* service;
};

struct _IdentityRequestClass {
	GObjectClass parent_class;
};

struct _Rule {
	char* pattern;
	char* always_confirm;
};

struct _Block1Data {
	int _ref_count_;
	IdentityManagerView * self;
	IdCard* identity;
};


static gpointer identity_manager_view_parent_class = NULL;

GType identity_manager_view_get_type (void) G_GNUC_CONST;
gpointer identity_manager_app_ref (gpointer instance);
void identity_manager_app_unref (gpointer instance);
GParamSpec* param_spec_identity_manager_app (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_identity_manager_app (GValue* value, gpointer v_object);
void value_take_identity_manager_app (GValue* value, gpointer v_object);
gpointer value_get_identity_manager_app (const GValue* value);
GType identity_manager_app_get_type (void) G_GNUC_CONST;
GType identity_manager_model_get_type (void) G_GNUC_CONST;
GType identity_request_get_type (void) G_GNUC_CONST;
GType custom_vbox_get_type (void) G_GNUC_CONST;
GType id_card_get_type (void) G_GNUC_CONST;
#define IDENTITY_MANAGER_VIEW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_IDENTITY_MANAGER_VIEW, IdentityManagerViewPrivate))
enum  {
	IDENTITY_MANAGER_VIEW_DUMMY_PROPERTY
};
static GType identity_manager_view_columns_get_type (void) G_GNUC_UNUSED;
static void _g_slist_free_g_object_unref (GSList* self);
#define IDENTITY_MANAGER_VIEW_WINDOW_WIDTH 400
#define IDENTITY_MANAGER_VIEW_WINDOW_HEIGHT 500
#define IDENTITY_MANAGER_VIEW_layout "<menubar name='MenuBar'>" "        <menu name='FileMenu' action='FileMenuAction'>" "            <menuitem name='AddIdCard' action='AddIdCardAction' />" "            <separator />" "            <menuitem name='Quit' action='QuitAction' />" "        </menu>" "" "        <menu name='HelpMenu' action='HelpMenuAction'>" "             <menuitem name='About' action='AboutAction' />" "        </menu>" "</menubar>"
IdentityManagerView* identity_manager_view_new (IdentityManagerApp* app);
IdentityManagerView* identity_manager_view_construct (GType object_type, IdentityManagerApp* app);
static void identity_manager_view_build_ui (IdentityManagerView* self);
static void identity_manager_view_setup_list_model (IdentityManagerView* self);
static void identity_manager_view_load_id_cards (IdentityManagerView* self);
static void identity_manager_view_connect_signals (IdentityManagerView* self);
void identity_manager_view_on_card_list_changed (IdentityManagerView* self);
void identity_manager_view_add_candidate (IdentityManagerView* self, IdCard* idcard);
static gboolean identity_manager_view_visible_func (IdentityManagerView* self, GtkTreeModel* model, GtkTreeIter* iter);
const char* id_card_get_issuer (IdCard* self);
const char* id_card_get_display_name (IdCard* self);
char** id_card_get_services (IdCard* self, int* result_length1);
static gboolean _identity_manager_view_visible_func_gtk_tree_model_filter_visible_func (GtkTreeModel* model, GtkTreeIter* iter, gpointer self);
static void identity_manager_view_search_entry_icon_press_cb (IdentityManagerView* self, GtkEntryIconPosition pos, GdkEvent* event);
static void identity_manager_view_search_entry_text_changed_cb (IdentityManagerView* self);
static void identity_manager_view_redraw_id_card_widgets (IdentityManagerView* self);
static gboolean identity_manager_view_search_entry_key_press_event_cb (IdentityManagerView* self, GdkEventKey* e);
GType id_card_widget_get_type (void) G_GNUC_CONST;
static void identity_manager_view_remove_id_card_widget (IdentityManagerView* self, IdCardWidget* id_card_widget);
GeeLinkedList* identity_manager_model_get_card_list (IdentityManagerModel* self);
static void identity_manager_view_add_id_card_data (IdentityManagerView* self, IdCard* id_card);
static void identity_manager_view_add_id_card_widget (IdentityManagerView* self, IdCard* id_card);
static void identity_manager_view_fill_details (IdentityManagerView* self, IdCardWidget* id_card_widget);
IdCard* id_card_widget_get_id_card (IdCardWidget* self);
const char* id_card_get_username (IdCard* self);
const char* id_card_get_password (IdCard* self);
static void identity_manager_view_fill_services_vbox (IdentityManagerView* self, IdCard* id_card);
static void identity_manager_view_show_details (IdentityManagerView* self, IdCard* id_card);
static void identity_manager_view_details_identity_cb (IdentityManagerView* self, IdCardWidget* id_card_widget);
GType add_identity_dialog_get_type (void) G_GNUC_CONST;
static IdCard* identity_manager_view_get_id_card_data (IdentityManagerView* self, AddIdentityDialog* dialog);
IdCard* id_card_new (void);
IdCard* id_card_construct (GType object_type);
const char* add_identity_dialog_get_display_name (AddIdentityDialog* self);
void id_card_set_display_name (IdCard* self, const char* value);
const char* add_identity_dialog_get_issuer (AddIdentityDialog* self);
void id_card_set_issuer (IdCard* self, const char* value);
const char* add_identity_dialog_get_username (AddIdentityDialog* self);
void id_card_set_username (IdCard* self, const char* value);
const char* add_identity_dialog_get_password (AddIdentityDialog* self);
void id_card_set_password (IdCard* self, const char* value);
void id_card_set_services (IdCard* self, char** value, int value_length1);
GdkPixbuf* find_icon (const char* name, gint size);
static void identity_manager_view_remove_id_card_data (IdentityManagerView* self, IdCard* id_card);
IdCardWidget* id_card_widget_new (IdCard* id_card);
IdCardWidget* id_card_widget_construct (GType object_type, IdCard* id_card);
void custom_vbox_add_id_card_widget (CustomVBox* self, IdCardWidget* id_card_widget);
static void _identity_manager_view_details_identity_cb_id_card_widget_details_id (IdCardWidget* _sender, gpointer self);
static void identity_manager_view_remove_identity_cb (IdentityManagerView* self, IdCardWidget* id_card_widget);
static void _identity_manager_view_remove_identity_cb_id_card_widget_remove_id (IdCardWidget* _sender, gpointer self);
static void _lambda2_ (IdCardWidget* w, IdentityManagerView* self);
void identity_manager_view_send_identity_cb (IdentityManagerView* self, IdCard* identity);
static void __lambda2__id_card_widget_send_id (IdCardWidget* _sender, gpointer self);
void custom_vbox_receive_expanded_event (CustomVBox* self, IdCardWidget* id_card_widget);
static void _custom_vbox_receive_expanded_event_id_card_widget_expanded (IdCardWidget* _sender, gpointer self);
static void _identity_manager_view_fill_details_id_card_widget_expanded (IdCardWidget* _sender, gpointer self);
gboolean identity_manager_view_display_name_is_valid (IdentityManagerView* self, const char* name, char** candidate);
void identity_manager_view_insert_id_card (IdentityManagerView* self, IdCard* id_card);
void identity_manager_model_add_card (IdentityManagerModel* self, IdCard* card);
gboolean identity_manager_view_add_identity (IdentityManagerView* self, IdCard* id_card);
static void identity_manager_view_add_identity_manual_cb (IdentityManagerView* self);
AddIdentityDialog* add_identity_dialog_new (void);
AddIdentityDialog* add_identity_dialog_construct (GType object_type);
void custom_vbox_remove_id_card_widget (CustomVBox* self, IdCardWidget* id_card_widget);
static void identity_manager_view_remove_identity (IdentityManagerView* self, IdCardWidget* id_card_widget);
void identity_manager_model_remove_card (IdentityManagerModel* self, IdCard* card);
void identity_manager_view_select_identity (IdentityManagerView* self, IdentityRequest* request);
IdCardWidget* custom_vbox_get_current_idcard (CustomVBox* self);
GtkButton* id_card_widget_get_send_button (IdCardWidget* self);
const char* id_card_get_nai (IdCard* self);
static void _g_slist_free_g_free (GSList* self);
GType rule_get_type (void) G_GNUC_CONST;
Rule* rule_dup (const Rule* self);
void rule_free (Rule* self);
void rule_copy (const Rule* self, Rule* dest);
void rule_destroy (Rule* self);
Rule* id_card_get_rules (IdCard* self, int* result_length1);
static gboolean identity_manager_view_match_service_pattern (IdentityManagerView* self, const char* service, const char* pattern);
static gboolean _lambda3_ (Block1Data* _data1_);
static gboolean __lambda3__gsource_func (gpointer self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
void identity_manager_model_update_card (IdentityManagerModel* self, IdCard* card);
AddPasswordDialog* add_password_dialog_new (void);
AddPasswordDialog* add_password_dialog_construct (GType object_type);
GType add_password_dialog_get_type (void) G_GNUC_CONST;
const char* add_password_dialog_get_password (AddPasswordDialog* self);
gboolean add_password_dialog_get_remember (AddPasswordDialog* self);
void identity_request_return_identity (IdentityRequest* self, IdCard* id_card);
static void identity_manager_view_label_make_bold (IdentityManagerView* self, GtkLabel* label);
static void _lambda1_ (GtkButton* remove_button, IdentityManagerView* self);
void id_card_widget_update_id_card_label (IdCardWidget* self);
static void __lambda1__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void identity_manager_view_on_about_action (IdentityManagerView* self);
static GtkActionEntry* identity_manager_view_create_actions (IdentityManagerView* self, int* result_length1);
static void _vala_array_add1 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _identity_manager_view_add_identity_manual_cb_gtk_action_callback (GtkAction* action, gpointer self);
static void _vala_array_add2 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _gtk_main_quit_gtk_action_callback (GtkAction* action, gpointer self);
static void _vala_array_add3 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _vala_array_add4 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _identity_manager_view_on_about_action_gtk_action_callback (GtkAction* action, gpointer self);
static void _vala_array_add5 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void identity_manager_view_create_ui_manager (IdentityManagerView* self);
static void identity_manager_view_set_atk_name_description (IdentityManagerView* self, GtkWidget* widget, const char* name, const char* description);
GdkPixbuf* find_icon_sized (const char* name, GtkIconSize icon_size);
static void _identity_manager_view_search_entry_icon_press_cb_gtk_entry_icon_press (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self);
static void _identity_manager_view_search_entry_text_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static gboolean _identity_manager_view_search_entry_key_press_event_cb_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
CustomVBox* custom_vbox_new (IdentityManagerView* window, gboolean homogeneous, gint spacing);
CustomVBox* custom_vbox_construct (GType object_type, IdentityManagerView* window, gboolean homogeneous, gint spacing);
static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self);
static void _identity_manager_view_on_card_list_changed_identity_manager_model_card_list_changed (IdentityManagerModel* _sender, gpointer self);
static void identity_manager_view_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);



static GType identity_manager_view_columns_get_type (void) {
	static volatile gsize identity_manager_view_columns_type_id__volatile = 0;
	if (g_once_init_enter (&identity_manager_view_columns_type_id__volatile)) {
		static const GEnumValue values[] = {{IDENTITY_MANAGER_VIEW_COLUMNS_IDCARD_COL, "IDENTITY_MANAGER_VIEW_COLUMNS_IDCARD_COL", "idcard-col"}, {IDENTITY_MANAGER_VIEW_COLUMNS_LOGO_COL, "IDENTITY_MANAGER_VIEW_COLUMNS_LOGO_COL", "logo-col"}, {IDENTITY_MANAGER_VIEW_COLUMNS_ISSUER_COL, "IDENTITY_MANAGER_VIEW_COLUMNS_ISSUER_COL", "issuer-col"}, {IDENTITY_MANAGER_VIEW_COLUMNS_USERNAME_COL, "IDENTITY_MANAGER_VIEW_COLUMNS_USERNAME_COL", "username-col"}, {IDENTITY_MANAGER_VIEW_COLUMNS_PASSWORD_COL, "IDENTITY_MANAGER_VIEW_COLUMNS_PASSWORD_COL", "password-col"}, {IDENTITY_MANAGER_VIEW_COLUMNS_N_COLUMNS, "IDENTITY_MANAGER_VIEW_COLUMNS_N_COLUMNS", "n-columns"}, {0, NULL, NULL}};
		GType identity_manager_view_columns_type_id;
		identity_manager_view_columns_type_id = g_enum_register_static ("IdentityManagerViewColumns", values);
		g_once_init_leave (&identity_manager_view_columns_type_id__volatile, identity_manager_view_columns_type_id);
	}
	return identity_manager_view_columns_type_id__volatile;
}


static void _g_slist_free_g_object_unref (GSList* self) {
	g_slist_foreach (self, (GFunc) g_object_unref, NULL);
	g_slist_free (self);
}


static gpointer _identity_manager_app_ref0 (gpointer self) {
	return self ? identity_manager_app_ref (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


IdentityManagerView* identity_manager_view_construct (GType object_type, IdentityManagerApp* app) {
	IdentityManagerView * self;
	IdentityManagerApp* _tmp0_;
	IdentityManagerModel* _tmp1_;
	GQueue* _tmp2_;
	GHashTable* _tmp3_;
	g_return_val_if_fail (app != NULL, NULL);
	self = g_object_newv (object_type, 0, NULL);
	self->parent_app = (_tmp0_ = _identity_manager_app_ref0 (app), _identity_manager_app_unref0 (self->parent_app), _tmp0_);
	self->identities_manager = (_tmp1_ = _g_object_ref0 (self->parent_app->model), _g_object_unref0 (self->identities_manager), _tmp1_);
	self->request_queue = (_tmp2_ = g_queue_new (), _g_queue_free0 (self->request_queue), _tmp2_);
	self->priv->service_button_map = (_tmp3_ = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, g_free), _g_hash_table_unref0 (self->priv->service_button_map), _tmp3_);
	gtk_window_set_title ((GtkWindow*) self, "Moonshoot");
	gtk_window_set_position ((GtkWindow*) self, GTK_WIN_POS_CENTER);
	gtk_window_set_default_size ((GtkWindow*) self, IDENTITY_MANAGER_VIEW_WINDOW_WIDTH, IDENTITY_MANAGER_VIEW_WINDOW_HEIGHT);
	identity_manager_view_build_ui (self);
	identity_manager_view_setup_list_model (self);
	identity_manager_view_load_id_cards (self);
	identity_manager_view_connect_signals (self);
	return self;
}


IdentityManagerView* identity_manager_view_new (IdentityManagerApp* app) {
	return identity_manager_view_construct (TYPE_IDENTITY_MANAGER_VIEW, app);
}


void identity_manager_view_on_card_list_changed (IdentityManagerView* self) {
	g_return_if_fail (self != NULL);
	identity_manager_view_load_id_cards (self);
}


void identity_manager_view_add_candidate (IdentityManagerView* self, IdCard* idcard) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (idcard != NULL);
	self->priv->candidates = g_slist_append (self->priv->candidates, _g_object_ref0 (idcard));
}


static gboolean string_contains (const char* self, const char* needle) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	result = strstr (self, needle) != NULL;
	return result;
}


static gboolean identity_manager_view_visible_func (IdentityManagerView* self, GtkTreeModel* model, GtkTreeIter* iter) {
	gboolean result = FALSE;
	IdCard* id_card;
	char* entry_text;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (model != NULL, FALSE);
	id_card = NULL;
	gtk_tree_model_get (model, iter, IDENTITY_MANAGER_VIEW_COLUMNS_IDCARD_COL, &id_card, -1);
	if (id_card == NULL) {
		result = FALSE;
		_g_object_unref0 (id_card);
		return result;
	}
	if (self->priv->candidates != NULL) {
		gboolean is_candidate;
		is_candidate = FALSE;
		{
			GSList* candidate_collection;
			GSList* candidate_it;
			candidate_collection = self->priv->candidates;
			for (candidate_it = candidate_collection; candidate_it != NULL; candidate_it = candidate_it->next) {
				IdCard* candidate;
				candidate = _g_object_ref0 ((IdCard*) candidate_it->data);
				{
					if (candidate == id_card) {
						is_candidate = TRUE;
					}
					_g_object_unref0 (candidate);
				}
			}
		}
		if (!is_candidate) {
			result = FALSE;
			_g_object_unref0 (id_card);
			return result;
		}
	}
	entry_text = g_strdup (gtk_entry_get_text (self->priv->search_entry));
	if (entry_text == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = _vala_strcmp0 (entry_text, "") == 0;
	}
	if (_tmp0_) {
		result = TRUE;
		_g_free0 (entry_text);
		_g_object_unref0 (id_card);
		return result;
	}
	{
		char** _tmp1_;
		char** search_text_collection;
		int search_text_collection_length1;
		int search_text_it;
		search_text_collection = _tmp1_ = g_strsplit (entry_text, " ", 0);
		search_text_collection_length1 = _vala_array_length (_tmp1_);
		for (search_text_it = 0; search_text_it < _vala_array_length (_tmp1_); search_text_it = search_text_it + 1) {
			char* search_text;
			search_text = g_strdup (search_text_collection[search_text_it]);
			{
				char* search_text_casefold;
				gint _tmp2_;
				if (_vala_strcmp0 (search_text, "") == 0) {
					_g_free0 (search_text);
					continue;
				}
				search_text_casefold = g_utf8_casefold (search_text, -1);
				if (id_card_get_issuer (id_card) != NULL) {
					char* issuer_casefold;
					issuer_casefold = g_strdup (id_card_get_issuer (id_card));
					if (string_contains (issuer_casefold, search_text_casefold)) {
						result = TRUE;
						_g_free0 (issuer_casefold);
						_g_free0 (search_text_casefold);
						_g_free0 (search_text);
						search_text_collection = (_vala_array_free (search_text_collection, search_text_collection_length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (entry_text);
						_g_object_unref0 (id_card);
						return result;
					}
					_g_free0 (issuer_casefold);
				}
				if (id_card_get_display_name (id_card) != NULL) {
					char* display_name_casefold;
					display_name_casefold = g_utf8_casefold (id_card_get_display_name (id_card), -1);
					if (string_contains (display_name_casefold, search_text_casefold)) {
						result = TRUE;
						_g_free0 (display_name_casefold);
						_g_free0 (search_text_casefold);
						_g_free0 (search_text);
						search_text_collection = (_vala_array_free (search_text_collection, search_text_collection_length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (entry_text);
						_g_object_unref0 (id_card);
						return result;
					}
					_g_free0 (display_name_casefold);
				}
				if (_tmp2_ > 0) {
					{
						gint _tmp3_;
						char** service_collection;
						int service_collection_length1;
						int service_it;
						service_collection = id_card_get_services (id_card, &_tmp3_);
						service_collection_length1 = _tmp3_;
						for (service_it = 0; service_it < _tmp3_; service_it = service_it + 1) {
							char* service;
							service = g_strdup (service_collection[service_it]);
							{
								char* service_casefold;
								service_casefold = g_utf8_casefold (service, -1);
								if (string_contains (service_casefold, search_text_casefold)) {
									result = TRUE;
									_g_free0 (service_casefold);
									_g_free0 (service);
									_g_free0 (search_text_casefold);
									_g_free0 (search_text);
									search_text_collection = (_vala_array_free (search_text_collection, search_text_collection_length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (entry_text);
									_g_object_unref0 (id_card);
									return result;
								}
								_g_free0 (service_casefold);
								_g_free0 (service);
							}
						}
					}
				}
				_g_free0 (search_text_casefold);
				_g_free0 (search_text);
			}
		}
		search_text_collection = (_vala_array_free (search_text_collection, search_text_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	result = FALSE;
	_g_free0 (entry_text);
	_g_object_unref0 (id_card);
	return result;
}


static gboolean _identity_manager_view_visible_func_gtk_tree_model_filter_visible_func (GtkTreeModel* model, GtkTreeIter* iter, gpointer self) {
	gboolean result;
	result = identity_manager_view_visible_func (self, model, iter);
	return result;
}


static void identity_manager_view_setup_list_model (IdentityManagerView* self) {
	GtkTreeModelFilter* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->listmodel = gtk_list_store_new ((gint) IDENTITY_MANAGER_VIEW_COLUMNS_N_COLUMNS, TYPE_ID_CARD, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
	self->priv->filter = (_tmp0_ = (GtkTreeModelFilter*) gtk_tree_model_filter_new ((GtkTreeModel*) self->priv->listmodel, NULL), _g_object_unref0 (self->priv->filter), _tmp0_);
	gtk_tree_model_filter_set_visible_func (self->priv->filter, _identity_manager_view_visible_func_gtk_tree_model_filter_visible_func, g_object_ref (self), g_object_unref);
}


static void identity_manager_view_search_entry_icon_press_cb (IdentityManagerView* self, GtkEntryIconPosition pos, GdkEvent* event) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	if (pos == GTK_ENTRY_ICON_PRIMARY) {
		g_print ("Search entry icon pressed\n");
	} else {
		gtk_entry_set_text (self->priv->search_entry, "");
	}
}


static void identity_manager_view_search_entry_text_changed_cb (IdentityManagerView* self) {
	gboolean has_text;
	g_return_if_fail (self != NULL);
	gtk_tree_model_filter_refilter (self->priv->filter);
	identity_manager_view_redraw_id_card_widgets (self);
	has_text = gtk_entry_get_text_length (self->priv->search_entry) > 0;
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, has_text);
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, has_text);
	gtk_widget_set_visible ((GtkWidget*) self->priv->vbox_right, FALSE);
}


static gboolean identity_manager_view_search_entry_key_press_event_cb (IdentityManagerView* self, GdkEventKey* e) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (_vala_strcmp0 (gdk_keyval_name ((*e).keyval), "Escape") == 0) {
		gtk_entry_set_text (self->priv->search_entry, "");
	}
	result = FALSE;
	return result;
}


static void identity_manager_view_load_id_cards (IdentityManagerView* self) {
	GList* children;
	IdCard* _tmp0_;
	GeeLinkedList* card_list;
	g_return_if_fail (self != NULL);
	children = gtk_container_get_children ((GtkContainer*) self->priv->custom_vbox);
	{
		GList* id_card_widget_collection;
		GList* id_card_widget_it;
		id_card_widget_collection = children;
		for (id_card_widget_it = id_card_widget_collection; id_card_widget_it != NULL; id_card_widget_it = id_card_widget_it->next) {
			GtkWidget* id_card_widget;
			id_card_widget = (GtkWidget*) id_card_widget_it->data;
			{
				identity_manager_view_remove_id_card_widget (self, ID_CARD_WIDGET (id_card_widget));
			}
		}
	}
	self->priv->default_id_card = (_tmp0_ = NULL, _g_object_unref0 (self->priv->default_id_card), _tmp0_);
	card_list = identity_manager_model_get_card_list (self->identities_manager);
	if (card_list == NULL) {
		_g_object_unref0 (card_list);
		_g_list_free0 (children);
		return;
	}
	{
		GeeIterator* _id_card_it;
		_id_card_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) card_list);
		while (TRUE) {
			IdCard* id_card;
			if (!gee_iterator_next (_id_card_it)) {
				break;
			}
			id_card = (IdCard*) gee_iterator_get (_id_card_it);
			identity_manager_view_add_id_card_data (self, id_card);
			identity_manager_view_add_id_card_widget (self, id_card);
			_g_object_unref0 (id_card);
		}
		_g_object_unref0 (_id_card_it);
	}
	if (gee_collection_get_size ((GeeCollection*) card_list) > 0) {
		IdCard* _tmp1_;
		self->priv->default_id_card = (_tmp1_ = (IdCard*) gee_abstract_list_first ((GeeAbstractList*) card_list), _g_object_unref0 (self->priv->default_id_card), _tmp1_);
	}
	_g_object_unref0 (card_list);
	_g_list_free0 (children);
}


static void identity_manager_view_fill_details (IdentityManagerView* self, IdCardWidget* id_card_widget) {
	IdCard* id_card;
	char* _tmp0_;
	GList* children;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	id_card = _g_object_ref0 (id_card_widget_get_id_card (id_card_widget));
	gtk_entry_set_text (self->priv->username_entry, id_card_get_username (id_card));
	_tmp0_ = g_strdup (id_card_get_password (id_card));
	if (_tmp0_ == NULL) {
		char* _tmp1_;
		_tmp0_ = (_tmp1_ = g_strdup (""), _g_free0 (_tmp0_), _tmp1_);
	}
	gtk_entry_set_text (self->priv->password_entry, _tmp0_);
	children = gtk_container_get_children ((GtkContainer*) self->priv->services_internal_vbox);
	{
		GList* hbox_collection;
		GList* hbox_it;
		hbox_collection = children;
		for (hbox_it = hbox_collection; hbox_it != NULL; hbox_it = hbox_it->next) {
			GtkWidget* hbox;
			hbox = (GtkWidget*) hbox_it->data;
			{
				gtk_object_destroy ((GtkObject*) hbox);
			}
		}
	}
	identity_manager_view_fill_services_vbox (self, id_card_widget_get_id_card (id_card_widget));
	_g_list_free0 (children);
	_g_free0 (_tmp0_);
	_g_object_unref0 (id_card);
}


static void identity_manager_view_show_details (IdentityManagerView* self, IdCard* id_card) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	gtk_widget_set_visible ((GtkWidget*) self->priv->vbox_right, !gtk_widget_get_visible ((GtkWidget*) self->priv->vbox_right));
	if (gtk_widget_get_visible ((GtkWidget*) self->priv->vbox_right) == FALSE) {
		gtk_window_resize ((GtkWindow*) self, IDENTITY_MANAGER_VIEW_WINDOW_WIDTH, IDENTITY_MANAGER_VIEW_WINDOW_HEIGHT);
	}
}


static void identity_manager_view_details_identity_cb (IdentityManagerView* self, IdCardWidget* id_card_widget) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	identity_manager_view_fill_details (self, id_card_widget);
	identity_manager_view_show_details (self, id_card_widget_get_id_card (id_card_widget));
}


static IdCard* identity_manager_view_get_id_card_data (IdentityManagerView* self, AddIdentityDialog* dialog) {
	IdCard* result = NULL;
	IdCard* id_card;
	char** _tmp0_ = NULL;
	char** _tmp1_;
	gint _tmp1__length1;
	char** _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (dialog != NULL, NULL);
	id_card = id_card_new ();
	id_card_set_display_name (id_card, add_identity_dialog_get_display_name (dialog));
	id_card_set_issuer (id_card, add_identity_dialog_get_issuer (dialog));
	if (_vala_strcmp0 (id_card_get_issuer (id_card), "") == 0) {
		id_card_set_issuer (id_card, "Issuer");
	}
	id_card_set_username (id_card, add_identity_dialog_get_username (dialog));
	id_card_set_password (id_card, add_identity_dialog_get_password (dialog));
	_tmp2_ = (_tmp1_ = (_tmp0_ = g_new0 (char*, 0 + 1), _tmp0_), _tmp1__length1 = 0, _tmp1_);
	id_card_set_services (id_card, _tmp2_, 0);
	_tmp1_ = (_vala_array_free (_tmp1_, _tmp1__length1, (GDestroyNotify) g_free), NULL);
	g_object_set_data_full ((GObject*) id_card, "pixbuf", find_icon ("avatar-default", 48), g_object_unref);
	result = id_card;
	return result;
}


static void identity_manager_view_add_id_card_data (IdentityManagerView* self, IdCard* id_card) {
	GtkTreeIter iter = {0};
	GdkPixbuf* pixbuf;
	GdkPixbuf* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	pixbuf = NULL;
	gtk_list_store_append (self->priv->listmodel, &iter);
	pixbuf = (_tmp0_ = _g_object_ref0 ((GdkPixbuf*) g_object_get_data ((GObject*) id_card, "pixbuf")), _g_object_unref0 (pixbuf), _tmp0_);
	gtk_list_store_set (self->priv->listmodel, &iter, IDENTITY_MANAGER_VIEW_COLUMNS_IDCARD_COL, id_card, IDENTITY_MANAGER_VIEW_COLUMNS_LOGO_COL, pixbuf, IDENTITY_MANAGER_VIEW_COLUMNS_ISSUER_COL, id_card_get_issuer (id_card), IDENTITY_MANAGER_VIEW_COLUMNS_USERNAME_COL, id_card_get_username (id_card), IDENTITY_MANAGER_VIEW_COLUMNS_PASSWORD_COL, id_card_get_password (id_card), -1);
	_g_object_unref0 (pixbuf);
}


static void identity_manager_view_remove_id_card_data (IdentityManagerView* self, IdCard* id_card) {
	GtkTreeIter iter = {0};
	char* issuer;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	issuer = NULL;
	if (gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->listmodel, &iter)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					if (!gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->listmodel, &iter)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				gtk_tree_model_get ((GtkTreeModel*) self->priv->listmodel, &iter, IDENTITY_MANAGER_VIEW_COLUMNS_ISSUER_COL, &issuer, -1);
				if (_vala_strcmp0 (id_card_get_issuer (id_card), issuer) == 0) {
					gtk_list_store_remove (self->priv->listmodel, &iter);
					break;
				}
			}
		}
	}
	_g_free0 (issuer);
}


static void _identity_manager_view_details_identity_cb_id_card_widget_details_id (IdCardWidget* _sender, gpointer self) {
	identity_manager_view_details_identity_cb (self, _sender);
}


static void _identity_manager_view_remove_identity_cb_id_card_widget_remove_id (IdCardWidget* _sender, gpointer self) {
	identity_manager_view_remove_identity_cb (self, _sender);
}


static void _lambda2_ (IdCardWidget* w, IdentityManagerView* self) {
	g_return_if_fail (w != NULL);
	identity_manager_view_send_identity_cb (self, id_card_widget_get_id_card (w));
}


static void __lambda2__id_card_widget_send_id (IdCardWidget* _sender, gpointer self) {
	_lambda2_ (_sender, self);
}


static void _custom_vbox_receive_expanded_event_id_card_widget_expanded (IdCardWidget* _sender, gpointer self) {
	custom_vbox_receive_expanded_event (self, _sender);
}


static void _identity_manager_view_fill_details_id_card_widget_expanded (IdCardWidget* _sender, gpointer self) {
	identity_manager_view_fill_details (self, _sender);
}


static void identity_manager_view_add_id_card_widget (IdentityManagerView* self, IdCard* id_card) {
	IdCardWidget* id_card_widget;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	id_card_widget = g_object_ref_sink (id_card_widget_new (id_card));
	custom_vbox_add_id_card_widget (self->priv->custom_vbox, id_card_widget);
	g_signal_connect_object (id_card_widget, "details-id", (GCallback) _identity_manager_view_details_identity_cb_id_card_widget_details_id, self, 0);
	g_signal_connect_object (id_card_widget, "remove-id", (GCallback) _identity_manager_view_remove_identity_cb_id_card_widget_remove_id, self, 0);
	g_signal_connect_object (id_card_widget, "send-id", (GCallback) __lambda2__id_card_widget_send_id, self, 0);
	g_signal_connect_object (id_card_widget, "expanded", (GCallback) _custom_vbox_receive_expanded_event_id_card_widget_expanded, self->priv->custom_vbox, 0);
	g_signal_connect_object (id_card_widget, "expanded", (GCallback) _identity_manager_view_fill_details_id_card_widget_expanded, self, 0);
	_g_object_unref0 (id_card_widget);
}


gboolean identity_manager_view_display_name_is_valid (IdentityManagerView* self, const char* name, char** candidate) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (name != NULL, FALSE);
	if (candidate != NULL) {
		*candidate = NULL;
	}
	{
		GeeLinkedList* _tmp0_;
		GeeIterator* _tmp1_;
		GeeIterator* _id_card_it;
		_id_card_it = (_tmp1_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) (_tmp0_ = identity_manager_model_get_card_list (self->identities_manager))), _g_object_unref0 (_tmp0_), _tmp1_);
		while (TRUE) {
			IdCard* id_card;
			if (!gee_iterator_next (_id_card_it)) {
				break;
			}
			id_card = (IdCard*) gee_iterator_get (_id_card_it);
			if (_vala_strcmp0 (id_card_get_display_name (id_card), name) == 0) {
				if ((candidate) != NULL) {
					{
						gint i;
						i = 0;
						{
							gboolean _tmp2_;
							_tmp2_ = TRUE;
							while (TRUE) {
								char* tmp;
								if (!_tmp2_) {
									i++;
								}
								_tmp2_ = FALSE;
								if (!(i < 1000)) {
									break;
								}
								tmp = g_strdup_printf ("%s %d", name, i);
								if (identity_manager_view_display_name_is_valid (self, tmp, NULL)) {
									char* _tmp3_;
									*candidate = (_tmp3_ = g_strdup (tmp), _g_free0 (*candidate), _tmp3_);
									_g_free0 (tmp);
									break;
								}
								_g_free0 (tmp);
							}
						}
					}
				}
				result = FALSE;
				_g_object_unref0 (id_card);
				_g_object_unref0 (_id_card_it);
				return result;
			}
			_g_object_unref0 (id_card);
		}
		_g_object_unref0 (_id_card_it);
	}
	result = TRUE;
	return result;
}


void identity_manager_view_insert_id_card (IdentityManagerView* self, IdCard* id_card) {
	char* candidate;
	char* _tmp0_ = NULL;
	gboolean _tmp1_;
	char* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	candidate = NULL;
	if (!(_tmp1_ = identity_manager_view_display_name_is_valid (self, id_card_get_display_name (id_card), &_tmp0_), candidate = (_tmp2_ = _tmp0_, _g_free0 (candidate), _tmp2_), _tmp1_)) {
		id_card_set_display_name (id_card, candidate);
	}
	identity_manager_model_add_card (self->identities_manager, id_card);
	_g_free0 (candidate);
}


gboolean identity_manager_view_add_identity (IdentityManagerView* self, IdCard* id_card) {
	gboolean result = FALSE;
	GtkMessageDialog* dialog;
	gint ret;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (id_card != NULL, FALSE);
	dialog = g_object_ref_sink ((GtkMessageDialog*) gtk_message_dialog_new ((GtkWindow*) self, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, _ ("Would you like to add '%s' ID Card to the ID Card Organizer?"), id_card_get_display_name (id_card)));
	gtk_widget_show_all ((GtkWidget*) dialog);
	ret = gtk_dialog_run ((GtkDialog*) dialog);
	gtk_widget_hide ((GtkWidget*) dialog);
	if (ret == GTK_RESPONSE_YES) {
		g_object_set_data_full ((GObject*) id_card, "pixbuf", find_icon ("avatar-default", 48), g_object_unref);
		identity_manager_view_insert_id_card (self, id_card);
		result = TRUE;
		_g_object_unref0 (dialog);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (dialog);
	return result;
}


static void identity_manager_view_add_identity_manual_cb (IdentityManagerView* self) {
	AddIdentityDialog* dialog;
	gint _result_;
	g_return_if_fail (self != NULL);
	dialog = g_object_ref_sink (add_identity_dialog_new ());
	_result_ = gtk_dialog_run ((GtkDialog*) dialog);
	switch (_result_) {
		case GTK_RESPONSE_OK:
		{
			IdCard* _tmp0_;
			identity_manager_view_insert_id_card (self, _tmp0_ = identity_manager_view_get_id_card_data (self, dialog));
			_g_object_unref0 (_tmp0_);
			break;
		}
		default:
		{
			break;
		}
	}
	gtk_object_destroy ((GtkObject*) dialog);
	_g_object_unref0 (dialog);
}


static void identity_manager_view_remove_id_card_widget (IdentityManagerView* self, IdCardWidget* id_card_widget) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	custom_vbox_remove_id_card_widget (self->priv->custom_vbox, id_card_widget);
}


static void identity_manager_view_remove_identity (IdentityManagerView* self, IdCardWidget* id_card_widget) {
	IdCard* id_card;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	id_card = _g_object_ref0 (id_card_widget_get_id_card (id_card_widget));
	identity_manager_view_remove_id_card_widget (self, id_card_widget);
	identity_manager_model_remove_card (self->identities_manager, id_card);
	_g_object_unref0 (id_card);
}


static void identity_manager_view_redraw_id_card_widgets (IdentityManagerView* self) {
	GtkTreeIter iter = {0};
	IdCard* id_card;
	GList* children;
	g_return_if_fail (self != NULL);
	id_card = NULL;
	children = gtk_container_get_children ((GtkContainer*) self->priv->custom_vbox);
	{
		GList* id_card_widget_collection;
		GList* id_card_widget_it;
		id_card_widget_collection = children;
		for (id_card_widget_it = id_card_widget_collection; id_card_widget_it != NULL; id_card_widget_it = id_card_widget_it->next) {
			GtkWidget* id_card_widget;
			id_card_widget = (GtkWidget*) id_card_widget_it->data;
			{
				gtk_object_destroy ((GtkObject*) id_card_widget);
			}
		}
	}
	if (gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->filter, &iter)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					if (!gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->filter, &iter)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				gtk_tree_model_get ((GtkTreeModel*) self->priv->filter, &iter, IDENTITY_MANAGER_VIEW_COLUMNS_IDCARD_COL, &id_card, -1);
				identity_manager_view_add_id_card_widget (self, id_card);
			}
		}
	}
	_g_list_free0 (children);
	_g_object_unref0 (id_card);
}


static void identity_manager_view_remove_identity_cb (IdentityManagerView* self, IdCardWidget* id_card_widget) {
	IdCard* id_card;
	GtkMessageDialog* dialog;
	gint _result_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	id_card = _g_object_ref0 (id_card_widget_get_id_card (id_card_widget));
	dialog = g_object_ref_sink ((GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, _ ("Are you sure you want to delete %s ID Card?"), id_card_get_issuer (id_card)));
	_result_ = gtk_dialog_run ((GtkDialog*) dialog);
	switch (_result_) {
		case GTK_RESPONSE_YES:
		{
			identity_manager_view_remove_identity (self, id_card_widget);
			break;
		}
		default:
		{
			break;
		}
	}
	gtk_object_destroy ((GtkObject*) dialog);
	_g_object_unref0 (dialog);
	_g_object_unref0 (id_card);
}


static void _g_slist_free_g_free (GSList* self) {
	g_slist_foreach (self, (GFunc) g_free, NULL);
	g_slist_free (self);
}


static gboolean _lambda3_ (Block1Data* _data1_) {
	IdentityManagerView * self;
	gboolean result = FALSE;
	self = _data1_->self;
	identity_manager_view_send_identity_cb (self, _data1_->identity);
	result = FALSE;
	return result;
}


static gboolean __lambda3__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda3_ (self);
	return result;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->self);
		_g_object_unref0 (_data1_->identity);
		g_slice_free (Block1Data, _data1_);
	}
}


void identity_manager_view_select_identity (IdentityManagerView* self, IdentityRequest* request) {
	Block1Data* _data1_;
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (request != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_data1_->identity = NULL;
	g_queue_push_tail (self->request_queue, _g_object_ref0 (request));
	if (custom_vbox_get_current_idcard (self->priv->custom_vbox) != NULL) {
		_tmp0_ = id_card_widget_get_send_button (custom_vbox_get_current_idcard (self->priv->custom_vbox)) != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gtk_widget_set_sensitive ((GtkWidget*) id_card_widget_get_send_button (custom_vbox_get_current_idcard (self->priv->custom_vbox)), TRUE);
	}
	if (request->select_default) {
		IdCard* _tmp1_;
		_data1_->identity = (_tmp1_ = _g_object_ref0 (self->priv->default_id_card), _g_object_unref0 (_data1_->identity), _tmp1_);
	}
	if (_data1_->identity == NULL) {
		gboolean _tmp2_ = FALSE;
		gboolean has_nai;
		gboolean _tmp3_ = FALSE;
		gboolean has_srv;
		gboolean confirm;
		IdCard* nai_provided;
		gboolean _tmp9_ = FALSE;
		if (request->nai != NULL) {
			_tmp2_ = _vala_strcmp0 (request->nai, "") != 0;
		} else {
			_tmp2_ = FALSE;
		}
		has_nai = _tmp2_;
		if (request->service != NULL) {
			_tmp3_ = _vala_strcmp0 (request->service, "") != 0;
		} else {
			_tmp3_ = FALSE;
		}
		has_srv = _tmp3_;
		confirm = FALSE;
		nai_provided = NULL;
		{
			GeeLinkedList* _tmp4_;
			GeeIterator* _tmp5_;
			GeeIterator* _id_it;
			_id_it = (_tmp5_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) (_tmp4_ = identity_manager_model_get_card_list (self->identities_manager))), _g_object_unref0 (_tmp4_), _tmp5_);
			while (TRUE) {
				IdCard* id;
				gboolean _tmp6_ = FALSE;
				if (!gee_iterator_next (_id_it)) {
					break;
				}
				id = (IdCard*) gee_iterator_get (_id_it);
				if (has_nai) {
					_tmp6_ = _vala_strcmp0 (request->nai, id_card_get_nai (id)) == 0;
				} else {
					_tmp6_ = FALSE;
				}
				if (_tmp6_) {
					IdCard* _tmp7_;
					nai_provided = (_tmp7_ = _g_object_ref0 (id), _g_object_unref0 (nai_provided), _tmp7_);
					identity_manager_view_add_candidate (self, id);
					_g_object_unref0 (id);
					continue;
				}
				if (has_srv) {
					{
						gint _tmp8_;
						char** srv_collection;
						int srv_collection_length1;
						int srv_it;
						srv_collection = id_card_get_services (id, &_tmp8_);
						srv_collection_length1 = _tmp8_;
						for (srv_it = 0; srv_it < _tmp8_; srv_it = srv_it + 1) {
							char* srv;
							srv = g_strdup (srv_collection[srv_it]);
							{
								if (_vala_strcmp0 (request->service, srv) == 0) {
									identity_manager_view_add_candidate (self, id);
									_g_free0 (srv);
									continue;
								}
								_g_free0 (srv);
							}
						}
					}
				}
				_g_object_unref0 (id);
			}
			_g_object_unref0 (_id_it);
		}
		if (has_srv) {
			_tmp9_ = g_slist_length (self->priv->candidates) > 1;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			{
				GSList* id_collection;
				GSList* id_it;
				id_collection = self->priv->candidates;
				for (id_it = id_collection; id_it != NULL; id_it = id_it->next) {
					IdCard* id;
					id = _g_object_ref0 ((IdCard*) id_it->data);
					{
						gint i;
						GSList* services_list;
						gboolean has_service;
						gint services_length1;
						gint _services_size_;
						char** _tmp15_;
						gint _tmp14_;
						char** services;
						char** _tmp17_;
						i = 0;
						services_list = NULL;
						has_service = FALSE;
						{
							gint _tmp10_;
							char** srv_collection;
							int srv_collection_length1;
							int srv_it;
							srv_collection = id_card_get_services (id, &_tmp10_);
							srv_collection_length1 = _tmp10_;
							for (srv_it = 0; srv_it < _tmp10_; srv_it = srv_it + 1) {
								char* srv;
								srv = g_strdup (srv_collection[srv_it]);
								{
									if (_vala_strcmp0 (srv, request->service) == 0) {
										has_service = TRUE;
										_g_free0 (srv);
										continue;
									}
									services_list = g_slist_append (services_list, g_strdup (srv));
									_g_free0 (srv);
								}
							}
						}
						if (!has_service) {
							__g_slist_free_g_free0 (services_list);
							_g_object_unref0 (id);
							continue;
						}
						if (g_slist_length (services_list) == 0) {
							char** _tmp11_ = NULL;
							char** _tmp12_;
							gint _tmp12__length1;
							char** _tmp13_;
							_tmp13_ = (_tmp12_ = (_tmp11_ = g_new0 (char*, 0 + 1), _tmp11_), _tmp12__length1 = 0, _tmp12_);
							id_card_set_services (id, _tmp13_, 0);
							_tmp12_ = (_vala_array_free (_tmp12_, _tmp12__length1, (GDestroyNotify) g_free), NULL);
							__g_slist_free_g_free0 (services_list);
							_g_object_unref0 (id);
							continue;
						}
						services = (_tmp15_ = g_new0 (char*, (_tmp14_ = g_slist_length (services_list)) + 1), services_length1 = _tmp14_, _services_size_ = services_length1, _tmp15_);
						{
							GSList* srv_collection;
							GSList* srv_it;
							srv_collection = services_list;
							for (srv_it = srv_collection; srv_it != NULL; srv_it = srv_it->next) {
								char* srv;
								srv = g_strdup ((const char*) srv_it->data);
								{
									char* _tmp16_;
									services[i] = (_tmp16_ = g_strdup (srv), _g_free0 (services[i]), _tmp16_);
									i++;
									_g_free0 (srv);
								}
							}
						}
						_tmp17_ = services;
						id_card_set_services (id, _tmp17_, services_length1);
						services = (_vala_array_free (services, services_length1, (GDestroyNotify) g_free), NULL);
						__g_slist_free_g_free0 (services_list);
						_g_object_unref0 (id);
					}
				}
			}
		}
		if (g_slist_length (self->priv->candidates) == 0) {
			{
				GeeLinkedList* _tmp18_;
				GeeIterator* _tmp19_;
				GeeIterator* _id_it;
				_id_it = (_tmp19_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) (_tmp18_ = identity_manager_model_get_card_list (self->identities_manager))), _g_object_unref0 (_tmp18_), _tmp19_);
				while (TRUE) {
					IdCard* id;
					if (!gee_iterator_next (_id_it)) {
						break;
					}
					id = (IdCard*) gee_iterator_get (_id_it);
					{
						gint _tmp20_;
						Rule* rule_collection;
						int rule_collection_length1;
						int rule_it;
						rule_collection = id_card_get_rules (id, &_tmp20_);
						rule_collection_length1 = _tmp20_;
						for (rule_it = 0; rule_it < _tmp20_; rule_it = rule_it + 1) {
							Rule _tmp21_ = {0};
							Rule rule;
							rule = (rule_copy (&rule_collection[rule_it], &_tmp21_), _tmp21_);
							{
								if (!identity_manager_view_match_service_pattern (self, request->service, rule.pattern)) {
									rule_destroy (&rule);
									continue;
								}
								self->priv->candidates = g_slist_append (self->priv->candidates, _g_object_ref0 (id));
								if (_vala_strcmp0 (rule.always_confirm, "true") == 0) {
									confirm = TRUE;
								}
								rule_destroy (&rule);
							}
						}
					}
					_g_object_unref0 (id);
				}
				_g_object_unref0 (_id_it);
			}
		}
		if (g_slist_length (self->priv->candidates) > 1) {
			gboolean _tmp22_ = FALSE;
			if (has_nai) {
				_tmp22_ = nai_provided != NULL;
			} else {
				_tmp22_ = FALSE;
			}
			if (_tmp22_) {
				IdCard* _tmp23_;
				_data1_->identity = (_tmp23_ = _g_object_ref0 (nai_provided), _g_object_unref0 (_data1_->identity), _tmp23_);
				confirm = FALSE;
			} else {
				confirm = TRUE;
			}
		} else {
			IdCard* _tmp24_;
			_data1_->identity = (_tmp24_ = _g_object_ref0 ((IdCard*) g_slist_nth_data (self->priv->candidates, (guint) 0)), _g_object_unref0 (_data1_->identity), _tmp24_);
		}
		if (confirm) {
			gtk_tree_model_filter_refilter (self->priv->filter);
			identity_manager_view_redraw_id_card_widgets (self);
			gtk_widget_show ((GtkWidget*) self);
			_g_object_unref0 (nai_provided);
			block1_data_unref (_data1_);
			return;
		}
		_g_object_unref0 (nai_provided);
	}
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, __lambda3__gsource_func, block1_data_ref (_data1_), block1_data_unref);
	block1_data_unref (_data1_);
	return;
}


static gboolean identity_manager_view_match_service_pattern (IdentityManagerView* self, const char* service, const char* pattern) {
	gboolean result = FALSE;
	GPatternSpec* pspec;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (service != NULL, FALSE);
	g_return_val_if_fail (pattern != NULL, FALSE);
	pspec = g_pattern_spec_new (pattern);
	result = g_pattern_match_string (pspec, service);
	_g_pattern_spec_free0 (pspec);
	return result;
}


void identity_manager_view_send_identity_cb (IdentityManagerView* self, IdCard* identity) {
	IdentityRequest* request;
	gboolean reset_password;
	gboolean _tmp0_ = FALSE;
	GSList* _tmp12_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (identity != NULL);
	g_return_if_fail (self->request_queue->length > 0);
	request = (IdentityRequest*) g_queue_pop_head (self->request_queue);
	reset_password = FALSE;
	if (request->service != NULL) {
		_tmp0_ = _vala_strcmp0 (request->service, "") != 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint services_length1;
		gint _services_size_;
		char** _tmp2_;
		gint _tmp1_;
		char** services;
		gint _tmp7_;
		gint _tmp8_;
		char* _tmp9_;
		char** _tmp10_;
		services = (_tmp2_ = g_new0 (char*, (_tmp1_ + 1) + 1), services_length1 = _tmp1_ + 1, _services_size_ = services_length1, _tmp2_);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					gint _tmp4_;
					gint _tmp5_;
					char* _tmp6_;
					if (!_tmp3_) {
						i++;
					}
					_tmp3_ = FALSE;
					if (!(i < _tmp4_)) {
						break;
					}
					services[i] = (_tmp6_ = g_strdup (id_card_get_services (identity, &_tmp5_)[i]), _g_free0 (services[i]), _tmp6_);
				}
			}
		}
		services[_tmp7_] = (_tmp9_ = g_strdup (request->service), _g_free0 (services[_tmp7_]), _tmp9_);
		_tmp10_ = services;
		id_card_set_services (identity, _tmp10_, services_length1);
		identity_manager_model_update_card (self->identities_manager, identity);
		services = (_vala_array_free (services, services_length1, (GDestroyNotify) g_free), NULL);
	}
	if (id_card_get_password (identity) == NULL) {
		AddPasswordDialog* dialog;
		gint _result_;
		dialog = g_object_ref_sink (add_password_dialog_new ());
		_result_ = gtk_dialog_run ((GtkDialog*) dialog);
		switch (_result_) {
			case GTK_RESPONSE_OK:
			{
				id_card_set_password (identity, add_password_dialog_get_password (dialog));
				reset_password = !add_password_dialog_get_remember (dialog);
				break;
			}
			default:
			{
				identity = NULL;
				break;
			}
		}
		gtk_object_destroy ((GtkObject*) dialog);
		_g_object_unref0 (dialog);
	}
	if (g_queue_is_empty (self->request_queue)) {
		gtk_main_quit ();
	}
	if (identity != NULL) {
		IdCard* _tmp11_;
		self->priv->default_id_card = (_tmp11_ = _g_object_ref0 (identity), _g_object_unref0 (self->priv->default_id_card), _tmp11_);
	}
	identity_request_return_identity (request, identity);
	if (reset_password) {
		id_card_set_password (identity, NULL);
	}
	self->priv->candidates = (_tmp12_ = NULL, __g_slist_free_g_object_unref0 (self->priv->candidates), _tmp12_);
	_g_object_unref0 (request);
}


static void identity_manager_view_label_make_bold (IdentityManagerView* self, GtkLabel* label) {
	PangoFontDescription* font_desc;
	g_return_if_fail (self != NULL);
	g_return_if_fail (label != NULL);
	font_desc = pango_font_description_new ();
	pango_font_description_set_weight (font_desc, PANGO_WEIGHT_BOLD);
	gtk_widget_modify_font ((GtkWidget*) label, font_desc);
	_pango_font_description_free0 (font_desc);
}


static void _lambda1_ (GtkButton* remove_button, IdentityManagerView* self) {
	GtkMessageDialog* dialog;
	gint ret;
	g_return_if_fail (remove_button != NULL);
	dialog = g_object_ref_sink ((GtkMessageDialog*) gtk_message_dialog_new ((GtkWindow*) self, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, _ ("Are you sure you want to stop '%s' ID Card from being used with %s?"), id_card_get_display_name (id_card_widget_get_id_card (custom_vbox_get_current_idcard (self->priv->custom_vbox))), _ ("this service")));
	ret = gtk_dialog_run ((GtkDialog*) dialog);
	gtk_widget_hide ((GtkWidget*) dialog);
	if (ret == GTK_RESPONSE_YES) {
		IdCard* idcard;
		char* candidate;
		GSList* services;
		gint _tmp1_;
		char** _tmp2_;
		gint _tmp2__length1;
		char** _tmp3_;
		GList* children;
		idcard = _g_object_ref0 (id_card_widget_get_id_card (custom_vbox_get_current_idcard (self->priv->custom_vbox)));
		candidate = g_strdup ((const char*) g_hash_table_lookup (self->priv->service_button_map, remove_button));
		services = NULL;
		{
			gint _tmp0_;
			char** srv_collection;
			int srv_collection_length1;
			int srv_it;
			srv_collection = id_card_get_services (idcard, &_tmp0_);
			srv_collection_length1 = _tmp0_;
			for (srv_it = 0; srv_it < _tmp0_; srv_it = srv_it + 1) {
				char* srv;
				srv = g_strdup (srv_collection[srv_it]);
				{
					if (_vala_strcmp0 (srv, candidate) == 0) {
						_g_free0 (srv);
						continue;
					}
					services = g_slist_append (services, g_strdup (srv));
					_g_free0 (srv);
				}
			}
		}
		_tmp3_ = (_tmp2_ = g_new0 (char*, (_tmp1_ = g_slist_length (services)) + 1), _tmp2__length1 = _tmp1_, _tmp2_);
		id_card_set_services (idcard, _tmp3_, _tmp1_);
		_tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL);
		{
			gint j;
			j = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					gint _tmp5_;
					gint _tmp6_;
					gint _tmp7_;
					char* *_tmp8_;
					char* _tmp9_;
					if (!_tmp4_) {
						j++;
					}
					_tmp4_ = FALSE;
					if (!(j < _tmp5_)) {
						break;
					}
					_tmp8_ = &id_card_get_services (idcard, &_tmp7_)[j];
					(*_tmp8_) = (_tmp9_ = g_strdup ((const char*) g_slist_nth_data (services, (guint) j)), _g_free0 ((*_tmp8_)), _tmp9_);
				}
			}
		}
		children = gtk_container_get_children ((GtkContainer*) self->priv->services_internal_vbox);
		{
			GList* hbox_collection;
			GList* hbox_it;
			hbox_collection = children;
			for (hbox_it = hbox_collection; hbox_it != NULL; hbox_it = hbox_it->next) {
				GtkWidget* hbox;
				hbox = (GtkWidget*) hbox_it->data;
				{
					gtk_object_destroy ((GtkObject*) hbox);
				}
			}
		}
		identity_manager_view_fill_services_vbox (self, idcard);
		id_card_widget_update_id_card_label (custom_vbox_get_current_idcard (self->priv->custom_vbox));
		_g_list_free0 (children);
		__g_slist_free_g_free0 (services);
		_g_free0 (candidate);
		_g_object_unref0 (idcard);
	}
	_g_object_unref0 (dialog);
}


static void __lambda1__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	_lambda1_ (_sender, self);
}


static void identity_manager_view_fill_services_vbox (IdentityManagerView* self, IdCard* id_card) {
	gint i;
	gint _tmp0_;
	gint n_columns;
	GtkTable* services_table;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	i = 0;
	n_columns = _tmp0_;
	services_table = g_object_ref_sink ((GtkTable*) gtk_table_new ((guint) n_columns, (guint) 2, FALSE));
	gtk_table_set_col_spacings (services_table, (guint) 10);
	gtk_table_set_row_spacings (services_table, (guint) 10);
	gtk_container_add ((GtkContainer*) self->priv->services_internal_vbox, (GtkWidget*) services_table);
	g_hash_table_remove_all (self->priv->service_button_map);
	{
		gint _tmp1_;
		char** service_collection;
		int service_collection_length1;
		int service_it;
		service_collection = id_card_get_services (id_card, &_tmp1_);
		service_collection_length1 = _tmp1_;
		for (service_it = 0; service_it < _tmp1_; service_it = service_it + 1) {
			char* service;
			service = g_strdup (service_collection[service_it]);
			{
				GtkLabel* label;
				GtkButton* remove_button;
				label = g_object_ref_sink ((GtkLabel*) gtk_label_new (service));
				gtk_misc_set_alignment ((GtkMisc*) label, (float) 0, (float) 0.5);
				remove_button = g_object_ref_sink ((GtkButton*) gtk_button_new_from_stock (GTK_STOCK_REMOVE));
				g_hash_table_insert (self->priv->service_button_map, _g_object_ref0 (remove_button), g_strdup (service));
				g_signal_connect_object (remove_button, "clicked", (GCallback) __lambda1__gtk_button_clicked, self, 0);
				gtk_table_attach_defaults (services_table, (GtkWidget*) label, (guint) 0, (guint) 1, (guint) i, (guint) (i + 1));
				gtk_table_attach_defaults (services_table, (GtkWidget*) remove_button, (guint) 1, (guint) 2, (guint) i, (guint) (i + 1));
				i++;
				_g_object_unref0 (remove_button);
				_g_object_unref0 (label);
				_g_free0 (service);
			}
		}
	}
	gtk_widget_show_all ((GtkWidget*) self->priv->services_internal_vbox);
	_g_object_unref0 (services_table);
}


static void identity_manager_view_on_about_action (IdentityManagerView* self) {
	gint authors_length1;
	gint _authors_size_;
	char** _tmp1_;
	char** _tmp0_ = NULL;
	char** authors;
	char* copyright;
	char* license;
	g_return_if_fail (self != NULL);
	authors = (_tmp1_ = (_tmp0_ = g_new0 (char*, 4 + 1), _tmp0_[0] = g_strdup ("Javier Jardn <jjardon@codethink.co.uk>"), _tmp0_[1] = g_strdup ("Sam Thursfield <samthursfield@codethink.co.uk>"), _tmp0_[2] = g_strdup ("Alberto Ruiz <alberto.ruiz@codethink.co.uk>"), _tmp0_[3] = NULL, _tmp0_), authors_length1 = 4, _authors_size_ = authors_length1, _tmp1_);
	copyright = g_strdup ("Copyright 2011 JANET");
	license = g_strdup ("\n" \
"Copyright (c) 2011, JANET(UK)\n" \
"All rights reserved.\n" \
"\n" \
"Redistribution and use in source and binary forms, with or without\n" \
"modification, are permitted provided that the following conditions\n" \
"are met:\n" \
"\n" \
"1. Redistributions of source code must retain the above copyright\n" \
"   notice, this list of conditions and the following disclaimer.\n" \
"\n" \
"2. Redistributions in binary form must reproduce the above copyright\n" \
"   notice, this list of conditions and the following disclaimer in the" \
"\n" \
"   documentation and/or other materials provided with the distribution" \
".\n" \
"\n" \
"3. Neither the name of JANET(UK) nor the names of its contributors\n" \
"   may be used to endorse or promote products derived from this softwa" \
"re\n" \
"   without specific prior written permission.\n" \
"\n" \
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\" \
"\"AS IS\\\"\n" \
"AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, " \
"THE\n" \
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PUR" \
"POSE\n" \
"ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS" \
" BE LIABLE\n" \
"FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUEN" \
"TIAL\n" \
"DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOOD" \
"S\n" \
"OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n" \
"HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, ST" \
"RICT\n" \
"LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY " \
"WAY\n" \
"OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF" \
"\n" \
"SUCH DAMAGE.\n");
	gtk_show_about_dialog ((GtkWindow*) self, "comments", _ ("Moonshot project UI"), "copyright", copyright, "website", "http://www.project-moonshot.org/", "license", license, "website-label", _ ("Visit the Moonshot project web site"), "authors", authors, "translator-credits", _ ("translator-credits"), NULL, NULL);
	_g_free0 (license);
	_g_free0 (copyright);
	authors = (_vala_array_free (authors, authors_length1, (GDestroyNotify) g_free), NULL);
}


static void _vala_array_add1 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _identity_manager_view_add_identity_manual_cb_gtk_action_callback (GtkAction* action, gpointer self) {
	identity_manager_view_add_identity_manual_cb (self);
}


static void _vala_array_add2 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _gtk_main_quit_gtk_action_callback (GtkAction* action, gpointer self) {
	gtk_main_quit ();
}


static void _vala_array_add3 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _vala_array_add4 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _identity_manager_view_on_about_action_gtk_action_callback (GtkAction* action, gpointer self) {
	identity_manager_view_on_about_action (self);
}


static void _vala_array_add5 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static GtkActionEntry* identity_manager_view_create_actions (IdentityManagerView* self, int* result_length1) {
	GtkActionEntry* result = NULL;
	gint actions_length1;
	gint _actions_size_;
	GtkActionEntry* _tmp0_;
	GtkActionEntry* actions;
	GtkActionEntry _tmp1_ = {0};
	GtkActionEntry filemenu;
	GtkActionEntry _tmp2_ = {0};
	GtkActionEntry add;
	GtkActionEntry _tmp3_ = {0};
	GtkActionEntry quit;
	GtkActionEntry _tmp4_ = {0};
	GtkActionEntry helpmenu;
	GtkActionEntry _tmp5_ = {0};
	GtkActionEntry about;
	GtkActionEntry* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	actions = (_tmp0_ = g_new0 (GtkActionEntry, 0), actions_length1 = 0, _actions_size_ = actions_length1, _tmp0_);
	filemenu = (_tmp1_.name = "FileMenuAction", _tmp1_.stock_id = NULL, _tmp1_.label = N_ ("_File"), _tmp1_.accelerator = NULL, _tmp1_.tooltip = NULL, _tmp1_.callback = (GCallback) NULL, _tmp1_);
	_vala_array_add1 (&actions, &actions_length1, &_actions_size_, &filemenu);
	add = (_tmp2_.name = "AddIdCardAction", _tmp2_.stock_id = GTK_STOCK_ADD, _tmp2_.label = N_ ("Add ID Card"), _tmp2_.accelerator = NULL, _tmp2_.tooltip = N_ ("Add a new ID Card"), _tmp2_.callback = (GCallback) _identity_manager_view_add_identity_manual_cb_gtk_action_callback, _tmp2_);
	_vala_array_add2 (&actions, &actions_length1, &_actions_size_, &add);
	quit = (_tmp3_.name = "QuitAction", _tmp3_.stock_id = GTK_STOCK_QUIT, _tmp3_.label = N_ ("Quit"), _tmp3_.accelerator = "<control>Q", _tmp3_.tooltip = N_ ("Quit the application"), _tmp3_.callback = (GCallback) _gtk_main_quit_gtk_action_callback, _tmp3_);
	_vala_array_add3 (&actions, &actions_length1, &_actions_size_, &quit);
	helpmenu = (_tmp4_.name = "HelpMenuAction", _tmp4_.stock_id = NULL, _tmp4_.label = N_ ("_Help"), _tmp4_.accelerator = NULL, _tmp4_.tooltip = NULL, _tmp4_.callback = (GCallback) NULL, _tmp4_);
	_vala_array_add4 (&actions, &actions_length1, &_actions_size_, &helpmenu);
	about = (_tmp5_.name = "AboutAction", _tmp5_.stock_id = GTK_STOCK_ABOUT, _tmp5_.label = N_ ("About"), _tmp5_.accelerator = NULL, _tmp5_.tooltip = N_ ("About this application"), _tmp5_.callback = (GCallback) _identity_manager_view_on_about_action_gtk_action_callback, _tmp5_);
	_vala_array_add5 (&actions, &actions_length1, &_actions_size_, &about);
	result = (_tmp6_ = actions, *result_length1 = actions_length1, _tmp6_);
	return result;
	actions = (g_free (actions), NULL);
}


static void identity_manager_view_create_ui_manager (IdentityManagerView* self) {
	GtkActionGroup* action_group;
	gint _tmp0_;
	GtkActionEntry* _tmp1_;
	gint _tmp1__length1;
	GtkActionEntry* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	action_group = gtk_action_group_new ("GeneralActionGroup");
	_tmp2_ = (_tmp1_ = identity_manager_view_create_actions (self, &_tmp0_), _tmp1__length1 = _tmp0_, _tmp1_);
	gtk_action_group_add_actions (action_group, _tmp2_, _tmp0_, self);
	_tmp1_ = (g_free (_tmp1_), NULL);
	gtk_ui_manager_insert_action_group (self->priv->ui_manager, action_group, 0);
	{
		gtk_ui_manager_add_ui_from_string (self->priv->ui_manager, IDENTITY_MANAGER_VIEW_layout, (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "%s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (action_group);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	gtk_ui_manager_ensure_update (self->priv->ui_manager);
	_g_object_unref0 (action_group);
}


static void _identity_manager_view_search_entry_icon_press_cb_gtk_entry_icon_press (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self) {
	identity_manager_view_search_entry_icon_press_cb (self, p0, p1);
}


static void _identity_manager_view_search_entry_text_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	identity_manager_view_search_entry_text_changed_cb (self);
}


static gboolean _identity_manager_view_search_entry_key_press_event_cb_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = identity_manager_view_search_entry_key_press_event_cb (self, event);
	return result;
}


static void identity_manager_view_build_ui (IdentityManagerView* self) {
	GtkEntry* _tmp0_;
	GdkPixbuf* _tmp1_;
	GdkPixbuf* _tmp2_;
	CustomVBox* _tmp3_;
	GtkViewport* viewport;
	GtkScrolledWindow* scroll;
	GtkVBox* vbox_left;
	GtkLabel* login_vbox_title;
	GtkLabel* username_label;
	GtkEntry* _tmp4_;
	GtkLabel* password_label;
	GtkEntry* _tmp5_;
	GtkCheckButton* remember_checkbutton;
	GtkTable* login_table;
	GtkAlignment* login_vbox_alignment;
	GtkVBox* login_vbox;
	GtkLabel* services_vbox_title;
	GtkAlignment* services_vbox_alignment;
	GtkVBox* _tmp6_;
	GtkVBox* services_vbox;
	GtkVBox* _tmp7_;
	GtkHBox* hbox;
	GtkVBox* main_vbox;
	GtkWidget* menubar;
	g_return_if_fail (self != NULL);
	identity_manager_view_create_ui_manager (self);
	self->priv->search_entry = (_tmp0_ = g_object_ref_sink ((GtkEntry*) gtk_entry_new ()), _g_object_unref0 (self->priv->search_entry), _tmp0_);
	identity_manager_view_set_atk_name_description (self, (GtkWidget*) self->priv->search_entry, _ ("Search entry"), _ ("Search for a specific ID Card"));
	gtk_entry_set_icon_from_pixbuf (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, _tmp1_ = find_icon_sized ("edit-find", GTK_ICON_SIZE_MENU));
	_g_object_unref0 (_tmp1_);
	gtk_entry_set_icon_tooltip_text (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, _ ("Search identity or service"));
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, FALSE);
	gtk_entry_set_icon_from_pixbuf (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, _tmp2_ = find_icon_sized ("process-stop", GTK_ICON_SIZE_MENU));
	_g_object_unref0 (_tmp2_);
	gtk_entry_set_icon_tooltip_text (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, _ ("Clear the current search"));
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, FALSE);
	g_signal_connect_object (self->priv->search_entry, "icon-press", (GCallback) _identity_manager_view_search_entry_icon_press_cb_gtk_entry_icon_press, self, 0);
	g_signal_connect_object ((GObject*) self->priv->search_entry, "notify::text", (GCallback) _identity_manager_view_search_entry_text_changed_cb_g_object_notify, self, 0);
	g_signal_connect_object ((GtkWidget*) self->priv->search_entry, "key-press-event", (GCallback) _identity_manager_view_search_entry_key_press_event_cb_gtk_widget_key_press_event, self, 0);
	self->priv->custom_vbox = (_tmp3_ = g_object_ref_sink (custom_vbox_new (self, FALSE, 6)), _g_object_unref0 (self->priv->custom_vbox), _tmp3_);
	viewport = g_object_ref_sink ((GtkViewport*) gtk_viewport_new (NULL, NULL));
	gtk_container_set_border_width ((GtkContainer*) viewport, (guint) 6);
	gtk_viewport_set_shadow_type (viewport, GTK_SHADOW_NONE);
	gtk_container_add ((GtkContainer*) viewport, (GtkWidget*) self->priv->custom_vbox);
	scroll = g_object_ref_sink ((GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL));
	gtk_scrolled_window_set_policy (scroll, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type (scroll, GTK_SHADOW_IN);
	gtk_scrolled_window_add_with_viewport (scroll, (GtkWidget*) viewport);
	vbox_left = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	gtk_box_pack_start ((GtkBox*) vbox_left, (GtkWidget*) self->priv->search_entry, FALSE, FALSE, (guint) 6);
	gtk_box_pack_start ((GtkBox*) vbox_left, (GtkWidget*) scroll, TRUE, TRUE, (guint) 0);
	gtk_widget_set_size_request ((GtkWidget*) vbox_left, IDENTITY_MANAGER_VIEW_WINDOW_WIDTH, 0);
	login_vbox_title = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Login: ")));
	identity_manager_view_label_make_bold (self, login_vbox_title);
	gtk_misc_set_alignment ((GtkMisc*) login_vbox_title, (float) 0, (float) 0.5);
	username_label = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Username:")));
	gtk_misc_set_alignment ((GtkMisc*) username_label, (float) 1, (float) 0.5);
	self->priv->username_entry = (_tmp4_ = g_object_ref_sink ((GtkEntry*) gtk_entry_new ()), _g_object_unref0 (self->priv->username_entry), _tmp4_);
	password_label = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Password:")));
	gtk_misc_set_alignment ((GtkMisc*) password_label, (float) 1, (float) 0.5);
	self->priv->password_entry = (_tmp5_ = g_object_ref_sink ((GtkEntry*) gtk_entry_new ()), _g_object_unref0 (self->priv->password_entry), _tmp5_);
	gtk_entry_set_invisible_char (self->priv->password_entry, (gunichar) '*');
	gtk_entry_set_visibility (self->priv->password_entry, FALSE);
	remember_checkbutton = g_object_ref_sink ((GtkCheckButton*) gtk_check_button_new_with_label (_ ("Remember password")));
	login_table = g_object_ref_sink ((GtkTable*) gtk_table_new ((guint) 3, (guint) 3, FALSE));
	gtk_table_set_col_spacings (login_table, (guint) 10);
	gtk_table_set_row_spacings (login_table, (guint) 10);
	gtk_table_attach_defaults (login_table, (GtkWidget*) username_label, (guint) 0, (guint) 1, (guint) 0, (guint) 1);
	gtk_table_attach_defaults (login_table, (GtkWidget*) self->priv->username_entry, (guint) 1, (guint) 2, (guint) 0, (guint) 1);
	gtk_table_attach_defaults (login_table, (GtkWidget*) password_label, (guint) 0, (guint) 1, (guint) 1, (guint) 2);
	gtk_table_attach_defaults (login_table, (GtkWidget*) self->priv->password_entry, (guint) 1, (guint) 2, (guint) 1, (guint) 2);
	gtk_table_attach_defaults (login_table, (GtkWidget*) remember_checkbutton, (guint) 1, (guint) 2, (guint) 2, (guint) 3);
	login_vbox_alignment = g_object_ref_sink ((GtkAlignment*) gtk_alignment_new ((float) 0, (float) 0, (float) 0, (float) 0));
	gtk_alignment_set_padding (login_vbox_alignment, (guint) 0, (guint) 0, (guint) 12, (guint) 0);
	gtk_container_add ((GtkContainer*) login_vbox_alignment, (GtkWidget*) login_table);
	login_vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 6));
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) login_vbox_title, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) login_vbox_alignment, FALSE, TRUE, (guint) 0);
	services_vbox_title = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Services:")));
	identity_manager_view_label_make_bold (self, services_vbox_title);
	gtk_misc_set_alignment ((GtkMisc*) services_vbox_title, (float) 0, (float) 0.5);
	services_vbox_alignment = g_object_ref_sink ((GtkAlignment*) gtk_alignment_new ((float) 0, (float) 0, (float) 0, (float) 0));
	gtk_alignment_set_padding (services_vbox_alignment, (guint) 0, (guint) 0, (guint) 12, (guint) 0);
	self->priv->services_internal_vbox = (_tmp6_ = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (TRUE, 6)), _g_object_unref0 (self->priv->services_internal_vbox), _tmp6_);
	gtk_container_add ((GtkContainer*) services_vbox_alignment, (GtkWidget*) self->priv->services_internal_vbox);
	services_vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 6));
	gtk_box_pack_start ((GtkBox*) services_vbox, (GtkWidget*) services_vbox_title, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) services_vbox, (GtkWidget*) services_vbox_alignment, FALSE, TRUE, (guint) 0);
	self->priv->vbox_right = (_tmp7_ = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 18)), _g_object_unref0 (self->priv->vbox_right), _tmp7_);
	gtk_box_pack_start ((GtkBox*) self->priv->vbox_right, (GtkWidget*) login_vbox, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) self->priv->vbox_right, (GtkWidget*) services_vbox, FALSE, TRUE, (guint) 0);
	hbox = g_object_ref_sink ((GtkHBox*) gtk_hbox_new (FALSE, 12));
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) vbox_left, TRUE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) self->priv->vbox_right, FALSE, FALSE, (guint) 0);
	main_vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	gtk_container_set_border_width ((GtkContainer*) main_vbox, (guint) 12);
	menubar = _g_object_ref0 (gtk_ui_manager_get_widget (self->priv->ui_manager, "/MenuBar"));
	gtk_box_pack_start ((GtkBox*) main_vbox, menubar, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) main_vbox, (GtkWidget*) hbox, TRUE, TRUE, (guint) 0);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) main_vbox);
	gtk_widget_show_all ((GtkWidget*) main_vbox);
	gtk_widget_hide ((GtkWidget*) self->priv->vbox_right);
	_g_object_unref0 (menubar);
	_g_object_unref0 (main_vbox);
	_g_object_unref0 (hbox);
	_g_object_unref0 (services_vbox);
	_g_object_unref0 (services_vbox_alignment);
	_g_object_unref0 (services_vbox_title);
	_g_object_unref0 (login_vbox);
	_g_object_unref0 (login_vbox_alignment);
	_g_object_unref0 (login_table);
	_g_object_unref0 (remember_checkbutton);
	_g_object_unref0 (password_label);
	_g_object_unref0 (username_label);
	_g_object_unref0 (login_vbox_title);
	_g_object_unref0 (vbox_left);
	_g_object_unref0 (scroll);
	_g_object_unref0 (viewport);
}


static void identity_manager_view_set_atk_name_description (IdentityManagerView* self, GtkWidget* widget, const char* name, const char* description) {
	AtkObject* atk_widget;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (description != NULL);
	atk_widget = _g_object_ref0 (gtk_widget_get_accessible (widget));
	atk_object_set_name (atk_widget, name);
	atk_object_set_description (atk_widget, description);
	_g_object_unref0 (atk_widget);
}


static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self) {
	gtk_main_quit ();
}


static void _identity_manager_view_on_card_list_changed_identity_manager_model_card_list_changed (IdentityManagerModel* _sender, gpointer self) {
	identity_manager_view_on_card_list_changed (self);
}


static void identity_manager_view_connect_signals (IdentityManagerView* self) {
	g_return_if_fail (self != NULL);
	g_signal_connect ((GtkObject*) self, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
	g_signal_connect_object (self->identities_manager, "card-list-changed", (GCallback) _identity_manager_view_on_card_list_changed_identity_manager_model_card_list_changed, self, 0);
}


static void identity_manager_view_class_init (IdentityManagerViewClass * klass) {
	identity_manager_view_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IdentityManagerViewPrivate));
	G_OBJECT_CLASS (klass)->finalize = identity_manager_view_finalize;
}


static void identity_manager_view_instance_init (IdentityManagerView * self) {
	self->priv = IDENTITY_MANAGER_VIEW_GET_PRIVATE (self);
	self->priv->ui_manager = gtk_ui_manager_new ();
}


static void identity_manager_view_finalize (GObject* obj) {
	IdentityManagerView * self;
	self = IDENTITY_MANAGER_VIEW (obj);
	_identity_manager_app_unref0 (self->parent_app);
	_g_object_unref0 (self->priv->ui_manager);
	_g_object_unref0 (self->priv->search_entry);
	_g_object_unref0 (self->priv->vbox_right);
	_g_object_unref0 (self->priv->custom_vbox);
	_g_object_unref0 (self->priv->services_internal_vbox);
	_g_object_unref0 (self->priv->username_entry);
	_g_object_unref0 (self->priv->password_entry);
	_g_object_unref0 (self->priv->filter);
	_g_object_unref0 (self->identities_manager);
	__g_slist_free_g_object_unref0 (self->priv->candidates);
	_g_object_unref0 (self->priv->default_id_card);
	_g_queue_free0 (self->request_queue);
	_g_hash_table_unref0 (self->priv->service_button_map);
	G_OBJECT_CLASS (identity_manager_view_parent_class)->finalize (obj);
}


GType identity_manager_view_get_type (void) {
	static volatile gsize identity_manager_view_type_id__volatile = 0;
	if (g_once_init_enter (&identity_manager_view_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IdentityManagerViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) identity_manager_view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IdentityManagerView), 0, (GInstanceInitFunc) identity_manager_view_instance_init, NULL };
		GType identity_manager_view_type_id;
		identity_manager_view_type_id = g_type_register_static (GTK_TYPE_WINDOW, "IdentityManagerView", &g_define_type_info, 0);
		g_once_init_leave (&identity_manager_view_type_id__volatile, identity_manager_view_type_id);
	}
	return identity_manager_view_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




