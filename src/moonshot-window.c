/* moonshot-window.c generated by valac 0.10.4, the Vala compiler
 * generated from moonshot-window.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <gdk/gdk.h>
#include <glib/gi18n-lib.h>
#include <pango/pango.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <atk/atk.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <dbus/dbus.h>
#include <config.h>


#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
typedef struct _MainWindowPrivate MainWindowPrivate;

#define TYPE_ID_CARD_WIDGET (id_card_widget_get_type ())
#define ID_CARD_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ID_CARD_WIDGET, IdCardWidget))
#define ID_CARD_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ID_CARD_WIDGET, IdCardWidgetClass))
#define IS_ID_CARD_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ID_CARD_WIDGET))
#define IS_ID_CARD_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ID_CARD_WIDGET))
#define ID_CARD_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ID_CARD_WIDGET, IdCardWidgetClass))

typedef struct _IdCardWidget IdCardWidget;
typedef struct _IdCardWidgetClass IdCardWidgetClass;

#define TYPE_CUSTOM_VBOX (custom_vbox_get_type ())
#define CUSTOM_VBOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOM_VBOX, CustomVBox))
#define CUSTOM_VBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOM_VBOX, CustomVBoxClass))
#define IS_CUSTOM_VBOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOM_VBOX))
#define IS_CUSTOM_VBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOM_VBOX))
#define CUSTOM_VBOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOM_VBOX, CustomVBoxClass))

typedef struct _CustomVBox CustomVBox;
typedef struct _CustomVBoxClass CustomVBoxClass;

#define TYPE_IDENTITIES_MANAGER (identities_manager_get_type ())
#define IDENTITIES_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDENTITIES_MANAGER, IdentitiesManager))
#define IDENTITIES_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDENTITIES_MANAGER, IdentitiesManagerClass))
#define IS_IDENTITIES_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDENTITIES_MANAGER))
#define IS_IDENTITIES_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDENTITIES_MANAGER))
#define IDENTITIES_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDENTITIES_MANAGER, IdentitiesManagerClass))

typedef struct _IdentitiesManager IdentitiesManager;
typedef struct _IdentitiesManagerClass IdentitiesManagerClass;

#define TYPE_MOONSHOT_SERVER (moonshot_server_get_type ())
#define MOONSHOT_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MOONSHOT_SERVER, MoonshotServer))
#define MOONSHOT_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MOONSHOT_SERVER, MoonshotServerClass))
#define IS_MOONSHOT_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MOONSHOT_SERVER))
#define IS_MOONSHOT_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MOONSHOT_SERVER))
#define MOONSHOT_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MOONSHOT_SERVER, MoonshotServerClass))

typedef struct _MoonshotServer MoonshotServer;
typedef struct _MoonshotServerClass MoonshotServerClass;

#define TYPE_IDENTITY_REQUEST (identity_request_get_type ())
#define IDENTITY_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDENTITY_REQUEST, IdentityRequest))
#define IDENTITY_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDENTITY_REQUEST, IdentityRequestClass))
#define IS_IDENTITY_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDENTITY_REQUEST))
#define IS_IDENTITY_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDENTITY_REQUEST))
#define IDENTITY_REQUEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDENTITY_REQUEST, IdentityRequestClass))

typedef struct _IdentityRequest IdentityRequest;
typedef struct _IdentityRequestClass IdentityRequestClass;

#define MAIN_WINDOW_TYPE_COLUMNS (main_window_columns_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_queue_free0(var) ((var == NULL) ? NULL : (var = (g_queue_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_ID_CARD (id_card_get_type ())
#define ID_CARD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ID_CARD, IdCard))
#define ID_CARD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ID_CARD, IdCardClass))
#define IS_ID_CARD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ID_CARD))
#define IS_ID_CARD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ID_CARD))
#define ID_CARD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ID_CARD, IdCardClass))

typedef struct _IdCard IdCard;
typedef struct _IdCardClass IdCardClass;
typedef struct _IdentitiesManagerPrivate IdentitiesManagerPrivate;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

#define TYPE_ADD_IDENTITY_DIALOG (add_identity_dialog_get_type ())
#define ADD_IDENTITY_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ADD_IDENTITY_DIALOG, AddIdentityDialog))
#define ADD_IDENTITY_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ADD_IDENTITY_DIALOG, AddIdentityDialogClass))
#define IS_ADD_IDENTITY_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ADD_IDENTITY_DIALOG))
#define IS_ADD_IDENTITY_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ADD_IDENTITY_DIALOG))
#define ADD_IDENTITY_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ADD_IDENTITY_DIALOG, AddIdentityDialogClass))

typedef struct _AddIdentityDialog AddIdentityDialog;
typedef struct _AddIdentityDialogClass AddIdentityDialogClass;

#define TYPE_ADD_PASSWORD_DIALOG (add_password_dialog_get_type ())
#define ADD_PASSWORD_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ADD_PASSWORD_DIALOG, AddPasswordDialog))
#define ADD_PASSWORD_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ADD_PASSWORD_DIALOG, AddPasswordDialogClass))
#define IS_ADD_PASSWORD_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ADD_PASSWORD_DIALOG))
#define IS_ADD_PASSWORD_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ADD_PASSWORD_DIALOG))
#define ADD_PASSWORD_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ADD_PASSWORD_DIALOG, AddPasswordDialogClass))

typedef struct _AddPasswordDialog AddPasswordDialog;
typedef struct _AddPasswordDialogClass AddPasswordDialogClass;
#define _pango_font_description_free0(var) ((var == NULL) ? NULL : (var = (pango_font_description_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
typedef struct _DBusObjectVTable _DBusObjectVTable;

struct _MainWindow {
	GtkWindow parent_instance;
	MainWindowPrivate * priv;
	IdCardWidget* selected_id_card_widget;
};

struct _MainWindowClass {
	GtkWindowClass parent_class;
};

struct _MainWindowPrivate {
	GtkUIManager* ui_manager;
	GtkEntry* search_entry;
	GtkVBox* vbox_rigth;
	CustomVBox* custom_vbox;
	GtkVBox* services_internal_vbox;
	GtkEntry* username_entry;
	GtkEntry* password_entry;
	GtkListStore* listmodel;
	GtkTreeModelFilter* filter;
	IdentitiesManager* identities_manager;
	MoonshotServer* ipc_server;
	GQueue* request_queue;
};

typedef enum  {
	MAIN_WINDOW_COLUMNS_IDCARD_COL,
	MAIN_WINDOW_COLUMNS_LOGO_COL,
	MAIN_WINDOW_COLUMNS_ISSUER_COL,
	MAIN_WINDOW_COLUMNS_USERNAME_COL,
	MAIN_WINDOW_COLUMNS_PASSWORD_COL,
	MAIN_WINDOW_COLUMNS_N_COLUMNS
} MainWindowColumns;

struct _IdentitiesManager {
	GObject parent_instance;
	IdentitiesManagerPrivate * priv;
	GSList* id_card_list;
};

struct _IdentitiesManagerClass {
	GObjectClass parent_class;
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};


static gpointer main_window_parent_class = NULL;

GType main_window_get_type (void) G_GNUC_CONST;
GType id_card_widget_get_type (void) G_GNUC_CONST;
GType custom_vbox_get_type (void) G_GNUC_CONST;
GType identities_manager_get_type (void) G_GNUC_CONST;
GType moonshot_server_get_type (void) G_GNUC_CONST;
GType identity_request_get_type (void) G_GNUC_CONST;
#define MAIN_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MAIN_WINDOW, MainWindowPrivate))
enum  {
	MAIN_WINDOW_DUMMY_PROPERTY
};
static GType main_window_columns_get_type (void) G_GNUC_UNUSED;
#define MAIN_WINDOW_WINDOW_WIDTH 400
#define MAIN_WINDOW_WINDOW_HEIGHT 500
#define MAIN_WINDOW_layout "\n" \
"<menubar name='MenuBar'>\n" \
"        <menu name='FileMenu' action='FileMenuAction'>\n" \
"            <menuitem name='AddIdCard' action='AddIdCardAction' />\n" \
"            <separator />\n" \
"            <menuitem name='Quit' action='QuitAction' />\n" \
"        </menu>\n" \
"\n" \
"        <menu name='HelpMenu' action='HelpMenuAction'>\n" \
"             <menuitem name='About' action='AboutAction' />\n" \
"        </menu>\n" \
"</menubar>\n"
MainWindow* main_window_new (void);
MainWindow* main_window_construct (GType object_type);
static void main_window_build_ui (MainWindow* self);
static void main_window_setup_identities_list (MainWindow* self);
static void main_window_load_gss_eap_id_file (MainWindow* self);
static void main_window_connect_signals (MainWindow* self);
static void main_window_init_ipc_server (MainWindow* self);
static gboolean main_window_visible_func (MainWindow* self, GtkTreeModel* model, GtkTreeIter* iter);
GType id_card_get_type (void) G_GNUC_CONST;
static gboolean _main_window_visible_func_gtk_tree_model_filter_visible_func (GtkTreeModel* model, GtkTreeIter* iter, gpointer self);
static void main_window_search_entry_icon_press_cb (MainWindow* self, GtkEntryIconPosition pos, GdkEvent* event);
static void main_window_search_entry_text_changed_cb (MainWindow* self);
static void main_window_redraw_id_card_widgets (MainWindow* self);
static gboolean main_window_search_entry_key_press_event_cb (MainWindow* self, GdkEventKey* e);
IdentitiesManager* identities_manager_new (void);
IdentitiesManager* identities_manager_construct (GType object_type);
IdCard* identities_manager_load_gss_eap_id_file (IdentitiesManager* self);
static void main_window_add_id_card_data (MainWindow* self, IdCard* id_card);
static void main_window_add_id_card_widget (MainWindow* self, IdCard* id_card);
static void main_window_load_id_cards (MainWindow* self);
static void main_window_fill_details (MainWindow* self, IdCardWidget* id_card_widget);
IdCard* id_card_widget_get_id_card (IdCardWidget* self);
const char* id_card_get_username (IdCard* self);
const char* id_card_get_password (IdCard* self);
static void main_window_fill_services_vbox (MainWindow* self, IdCard* id_card);
static void main_window_show_details (MainWindow* self, IdCard* id_card);
static void main_window_details_identity_cb (MainWindow* self, IdCardWidget* id_card_widget);
GType add_identity_dialog_get_type (void) G_GNUC_CONST;
static IdCard* main_window_get_id_card_data (MainWindow* self, AddIdentityDialog* dialog);
IdCard* id_card_new (void);
IdCard* id_card_construct (GType object_type);
const char* add_identity_dialog_get_issuer (AddIdentityDialog* self);
void id_card_set_issuer (IdCard* self, const char* value);
const char* id_card_get_issuer (IdCard* self);
const char* add_identity_dialog_get_username (AddIdentityDialog* self);
void id_card_set_username (IdCard* self, const char* value);
const char* add_identity_dialog_get_password (AddIdentityDialog* self);
void id_card_set_password (IdCard* self, const char* value);
void id_card_set_nai (IdCard* self, const char* value);
GdkPixbuf* find_icon (const char* name, gint size);
void id_card_set_pixbuf (IdCard* self, GdkPixbuf* value);
void id_card_set_services (IdCard* self, char** value, int value_length1);
GdkPixbuf* id_card_get_pixbuf (IdCard* self);
static void main_window_remove_id_card_data (MainWindow* self, IdCard* id_card);
IdCardWidget* id_card_widget_new (IdCard* id_card);
IdCardWidget* id_card_widget_construct (GType object_type, IdCard* id_card);
void custom_vbox_add_id_card_widget (CustomVBox* self, IdCardWidget* id_card_widget);
static void _main_window_details_identity_cb_id_card_widget_details_id (IdCardWidget* _sender, gpointer self);
static void main_window_remove_identity_cb (MainWindow* self, IdCardWidget* id_card_widget);
static void _main_window_remove_identity_cb_id_card_widget_remove_id (IdCardWidget* _sender, gpointer self);
void main_window_send_identity_cb (MainWindow* self, IdCardWidget* id_card_widget);
static void _main_window_send_identity_cb_id_card_widget_send_id (IdCardWidget* _sender, gpointer self);
void custom_vbox_receive_expanded_event (CustomVBox* self, IdCardWidget* id_card_widget);
static void _custom_vbox_receive_expanded_event_id_card_widget_expanded (IdCardWidget* _sender, gpointer self);
static void _main_window_fill_details_id_card_widget_expanded (IdCardWidget* _sender, gpointer self);
static void main_window_add_identity (MainWindow* self, AddIdentityDialog* dialog);
void identities_manager_store_id_cards (IdentitiesManager* self);
void identities_manager_store_gss_eap_id_file (IdentitiesManager* self, IdCard* id_card);
static void main_window_add_identity_cb (MainWindow* self);
AddIdentityDialog* add_identity_dialog_new (void);
AddIdentityDialog* add_identity_dialog_construct (GType object_type);
static void main_window_remove_id_card_widget (MainWindow* self, IdCardWidget* id_card_widget);
void custom_vbox_remove_id_card_widget (CustomVBox* self, IdCardWidget* id_card_widget);
static void main_window_remove_identity (MainWindow* self, IdCardWidget* id_card_widget);
void main_window_select_identity (MainWindow* self, IdentityRequest* request);
AddPasswordDialog* add_password_dialog_new (void);
AddPasswordDialog* add_password_dialog_construct (GType object_type);
GType add_password_dialog_get_type (void) G_GNUC_CONST;
const char* add_password_dialog_get_password (AddPasswordDialog* self);
gboolean add_password_dialog_get_remember (AddPasswordDialog* self);
void identity_request_return_identity (IdentityRequest* self, IdCard* id_card);
static void main_window_label_make_bold (MainWindow* self, GtkLabel* label);
char** id_card_get_services (IdCard* self, int* result_length1);
static void main_window_on_about_action (MainWindow* self);
static GtkActionEntry* main_window_create_actions (MainWindow* self, int* result_length1);
static void _vala_array_add1 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _main_window_add_identity_cb_gtk_action_callback (GtkAction* action, gpointer self);
static void _vala_array_add2 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _gtk_main_quit_gtk_action_callback (GtkAction* action, gpointer self);
static void _vala_array_add3 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _vala_array_add4 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _main_window_on_about_action_gtk_action_callback (GtkAction* action, gpointer self);
static void _vala_array_add5 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void main_window_create_ui_manager (MainWindow* self);
static void main_window_set_atk_name_description (MainWindow* self, GtkWidget* widget, const char* name, const char* description);
GdkPixbuf* find_icon_sized (const char* name, GtkIconSize icon_size);
static void _main_window_search_entry_icon_press_cb_gtk_entry_icon_press (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self);
static void _main_window_search_entry_text_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static gboolean _main_window_search_entry_key_press_event_cb_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
CustomVBox* custom_vbox_new (gboolean homogeneous, gint spacing);
CustomVBox* custom_vbox_construct (GType object_type, gboolean homogeneous, gint spacing);
static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self);
static guint _dynamic_request_name0 (DBusGProxy* self, const char* param1, guint param2, GError** error);
MoonshotServer* moonshot_server_new (GtkWindow* window);
MoonshotServer* moonshot_server_construct (GType object_type, GtkWindow* window);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
gint main_window_main (char** args, int args_length1);
static void main_window_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static int _vala_strcmp0 (const char * str1, const char * str2);



static GType main_window_columns_get_type (void) {
	static volatile gsize main_window_columns_type_id__volatile = 0;
	if (g_once_init_enter (&main_window_columns_type_id__volatile)) {
		static const GEnumValue values[] = {{MAIN_WINDOW_COLUMNS_IDCARD_COL, "MAIN_WINDOW_COLUMNS_IDCARD_COL", "idcard-col"}, {MAIN_WINDOW_COLUMNS_LOGO_COL, "MAIN_WINDOW_COLUMNS_LOGO_COL", "logo-col"}, {MAIN_WINDOW_COLUMNS_ISSUER_COL, "MAIN_WINDOW_COLUMNS_ISSUER_COL", "issuer-col"}, {MAIN_WINDOW_COLUMNS_USERNAME_COL, "MAIN_WINDOW_COLUMNS_USERNAME_COL", "username-col"}, {MAIN_WINDOW_COLUMNS_PASSWORD_COL, "MAIN_WINDOW_COLUMNS_PASSWORD_COL", "password-col"}, {MAIN_WINDOW_COLUMNS_N_COLUMNS, "MAIN_WINDOW_COLUMNS_N_COLUMNS", "n-columns"}, {0, NULL, NULL}};
		GType main_window_columns_type_id;
		main_window_columns_type_id = g_enum_register_static ("MainWindowColumns", values);
		g_once_init_leave (&main_window_columns_type_id__volatile, main_window_columns_type_id);
	}
	return main_window_columns_type_id__volatile;
}


MainWindow* main_window_construct (GType object_type) {
	MainWindow * self;
	GQueue* _tmp0_;
	self = g_object_newv (object_type, 0, NULL);
	self->priv->request_queue = (_tmp0_ = g_queue_new (), _g_queue_free0 (self->priv->request_queue), _tmp0_);
	gtk_window_set_title ((GtkWindow*) self, "Moonshoot");
	gtk_window_set_position ((GtkWindow*) self, GTK_WIN_POS_CENTER);
	gtk_window_set_default_size ((GtkWindow*) self, MAIN_WINDOW_WINDOW_WIDTH, MAIN_WINDOW_WINDOW_HEIGHT);
	main_window_build_ui (self);
	main_window_setup_identities_list (self);
	main_window_load_gss_eap_id_file (self);
	main_window_connect_signals (self);
	main_window_init_ipc_server (self);
	return self;
}


MainWindow* main_window_new (void) {
	return main_window_construct (TYPE_MAIN_WINDOW);
}


static gboolean string_contains (const char* self, const char* needle) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	result = strstr (self, needle) != NULL;
	return result;
}


static gboolean main_window_visible_func (MainWindow* self, GtkTreeModel* model, GtkTreeIter* iter) {
	gboolean result = FALSE;
	char* issuer;
	char* search_text;
	char* issuer_casefold;
	char* search_text_casefold;
	char* _tmp0_;
	gboolean _tmp1_ = FALSE;
	char* _tmp2_;
	char* _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (model != NULL, FALSE);
	issuer = NULL;
	search_text = NULL;
	issuer_casefold = NULL;
	search_text_casefold = NULL;
	gtk_tree_model_get (model, iter, MAIN_WINDOW_COLUMNS_ISSUER_COL, &issuer, -1);
	search_text = (_tmp0_ = g_strdup (gtk_entry_get_text (self->priv->search_entry)), _g_free0 (search_text), _tmp0_);
	if (issuer == NULL) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = search_text == NULL;
	}
	if (_tmp1_) {
		result = FALSE;
		_g_free0 (search_text_casefold);
		_g_free0 (issuer_casefold);
		_g_free0 (search_text);
		_g_free0 (issuer);
		return result;
	}
	issuer_casefold = (_tmp2_ = g_utf8_casefold (issuer, -1), _g_free0 (issuer_casefold), _tmp2_);
	search_text_casefold = (_tmp3_ = g_utf8_casefold (search_text, -1), _g_free0 (search_text_casefold), _tmp3_);
	if (string_contains (issuer_casefold, search_text_casefold)) {
		result = TRUE;
		_g_free0 (search_text_casefold);
		_g_free0 (issuer_casefold);
		_g_free0 (search_text);
		_g_free0 (issuer);
		return result;
	}
	result = FALSE;
	_g_free0 (search_text_casefold);
	_g_free0 (issuer_casefold);
	_g_free0 (search_text);
	_g_free0 (issuer);
	return result;
}


static gboolean _main_window_visible_func_gtk_tree_model_filter_visible_func (GtkTreeModel* model, GtkTreeIter* iter, gpointer self) {
	gboolean result;
	result = main_window_visible_func (self, model, iter);
	return result;
}


static void main_window_setup_identities_list (MainWindow* self) {
	GtkListStore* _tmp0_;
	GtkTreeModelFilter* _tmp1_;
	g_return_if_fail (self != NULL);
	self->priv->listmodel = (_tmp0_ = gtk_list_store_new ((gint) MAIN_WINDOW_COLUMNS_N_COLUMNS, TYPE_ID_CARD, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING), _g_object_unref0 (self->priv->listmodel), _tmp0_);
	self->priv->filter = (_tmp1_ = (GtkTreeModelFilter*) gtk_tree_model_filter_new ((GtkTreeModel*) self->priv->listmodel, NULL), _g_object_unref0 (self->priv->filter), _tmp1_);
	gtk_tree_model_filter_set_visible_func (self->priv->filter, _main_window_visible_func_gtk_tree_model_filter_visible_func, g_object_ref (self), g_object_unref);
}


static void main_window_search_entry_icon_press_cb (MainWindow* self, GtkEntryIconPosition pos, GdkEvent* event) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	if (pos == GTK_ENTRY_ICON_PRIMARY) {
		g_print ("Search entry icon pressed\n");
	} else {
		gtk_entry_set_text (self->priv->search_entry, "");
	}
}


static void main_window_search_entry_text_changed_cb (MainWindow* self) {
	gboolean has_text;
	g_return_if_fail (self != NULL);
	gtk_tree_model_filter_refilter (self->priv->filter);
	main_window_redraw_id_card_widgets (self);
	has_text = gtk_entry_get_text_length (self->priv->search_entry) > 0;
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, has_text);
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, has_text);
	gtk_widget_set_visible ((GtkWidget*) self->priv->vbox_rigth, FALSE);
	gtk_window_resize ((GtkWindow*) self, MAIN_WINDOW_WINDOW_WIDTH, MAIN_WINDOW_WINDOW_HEIGHT);
}


static gboolean main_window_search_entry_key_press_event_cb (MainWindow* self, GdkEventKey* e) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (_vala_strcmp0 (gdk_keyval_name ((*e).keyval), "Escape") == 0) {
		gtk_entry_set_text (self->priv->search_entry, "");
	}
	result = FALSE;
	return result;
}


static void main_window_load_gss_eap_id_file (MainWindow* self) {
	IdCard* id_card;
	IdentitiesManager* _tmp0_;
	IdCard* _tmp1_;
	g_return_if_fail (self != NULL);
	id_card = NULL;
	self->priv->identities_manager = (_tmp0_ = identities_manager_new (), _g_object_unref0 (self->priv->identities_manager), _tmp0_);
	id_card = (_tmp1_ = identities_manager_load_gss_eap_id_file (self->priv->identities_manager), _g_object_unref0 (id_card), _tmp1_);
	if (id_card != NULL) {
		main_window_add_id_card_data (self, id_card);
		main_window_add_id_card_widget (self, id_card);
	}
	_g_object_unref0 (id_card);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void main_window_load_id_cards (MainWindow* self) {
	IdentitiesManager* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->identities_manager = (_tmp0_ = identities_manager_new (), _g_object_unref0 (self->priv->identities_manager), _tmp0_);
	{
		GSList* id_card_collection;
		GSList* id_card_it;
		id_card_collection = self->priv->identities_manager->id_card_list;
		for (id_card_it = id_card_collection; id_card_it != NULL; id_card_it = id_card_it->next) {
			IdCard* id_card;
			id_card = _g_object_ref0 ((IdCard*) id_card_it->data);
			{
				main_window_add_id_card_data (self, id_card);
				main_window_add_id_card_widget (self, id_card);
				_g_object_unref0 (id_card);
			}
		}
	}
}


static void main_window_fill_details (MainWindow* self, IdCardWidget* id_card_widget) {
	IdCard* id_card;
	char* _tmp0_;
	GList* children;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	id_card = _g_object_ref0 (id_card_widget_get_id_card (id_card_widget));
	gtk_entry_set_text (self->priv->username_entry, id_card_get_username (id_card));
	_tmp0_ = g_strdup (id_card_get_password (id_card));
	if (_tmp0_ == NULL) {
		char* _tmp1_;
		_tmp0_ = (_tmp1_ = g_strdup (""), _g_free0 (_tmp0_), _tmp1_);
	}
	gtk_entry_set_text (self->priv->password_entry, _tmp0_);
	children = gtk_container_get_children ((GtkContainer*) self->priv->services_internal_vbox);
	{
		GList* hbox_collection;
		GList* hbox_it;
		hbox_collection = children;
		for (hbox_it = hbox_collection; hbox_it != NULL; hbox_it = hbox_it->next) {
			GtkWidget* hbox;
			hbox = (GtkWidget*) hbox_it->data;
			{
				gtk_object_destroy ((GtkObject*) hbox);
			}
		}
	}
	main_window_fill_services_vbox (self, id_card_widget_get_id_card (id_card_widget));
	_g_list_free0 (children);
	_g_free0 (_tmp0_);
	_g_object_unref0 (id_card);
}


static void main_window_show_details (MainWindow* self, IdCard* id_card) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	gtk_widget_set_visible ((GtkWidget*) self->priv->vbox_rigth, !gtk_widget_get_visible ((GtkWidget*) self->priv->vbox_rigth));
	if (gtk_widget_get_visible ((GtkWidget*) self->priv->vbox_rigth) == FALSE) {
		gtk_window_resize ((GtkWindow*) self, MAIN_WINDOW_WINDOW_WIDTH, MAIN_WINDOW_WINDOW_HEIGHT);
	}
}


static void main_window_details_identity_cb (MainWindow* self, IdCardWidget* id_card_widget) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	main_window_fill_details (self, id_card_widget);
	main_window_show_details (self, id_card_widget_get_id_card (id_card_widget));
}


static IdCard* main_window_get_id_card_data (MainWindow* self, AddIdentityDialog* dialog) {
	IdCard* result = NULL;
	IdCard* id_card;
	char* _tmp0_;
	char* _tmp1_;
	GdkPixbuf* _tmp2_;
	char** _tmp3_ = NULL;
	char** _tmp4_;
	gint _tmp4__length1;
	char** _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (dialog != NULL, NULL);
	id_card = id_card_new ();
	id_card_set_issuer (id_card, add_identity_dialog_get_issuer (dialog));
	if (_vala_strcmp0 (id_card_get_issuer (id_card), "") == 0) {
		id_card_set_issuer (id_card, "Issuer");
	}
	id_card_set_username (id_card, add_identity_dialog_get_username (dialog));
	id_card_set_password (id_card, add_identity_dialog_get_password (dialog));
	id_card_set_nai (id_card, _tmp1_ = g_strconcat (_tmp0_ = g_strconcat (id_card_get_username (id_card), "@", NULL), id_card_get_issuer (id_card), NULL));
	_g_free0 (_tmp1_);
	_g_free0 (_tmp0_);
	id_card_set_pixbuf (id_card, _tmp2_ = find_icon ("avatar-default", 48));
	_g_object_unref0 (_tmp2_);
	_tmp5_ = (_tmp4_ = (_tmp3_ = g_new0 (char*, 3 + 1), _tmp3_[0] = g_strdup ("email"), _tmp3_[1] = g_strdup ("jabber"), _tmp3_[2] = g_strdup ("irc"), _tmp3_), _tmp4__length1 = 3, _tmp4_);
	id_card_set_services (id_card, _tmp5_, 3);
	_tmp4_ = (_vala_array_free (_tmp4_, _tmp4__length1, (GDestroyNotify) g_free), NULL);
	result = id_card;
	return result;
}


static void main_window_add_id_card_data (MainWindow* self, IdCard* id_card) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	gtk_list_store_append (self->priv->listmodel, &iter);
	gtk_list_store_set (self->priv->listmodel, &iter, MAIN_WINDOW_COLUMNS_IDCARD_COL, id_card, MAIN_WINDOW_COLUMNS_LOGO_COL, id_card_get_pixbuf (id_card), MAIN_WINDOW_COLUMNS_ISSUER_COL, id_card_get_issuer (id_card), MAIN_WINDOW_COLUMNS_USERNAME_COL, id_card_get_username (id_card), MAIN_WINDOW_COLUMNS_PASSWORD_COL, id_card_get_password (id_card), -1);
}


static void main_window_remove_id_card_data (MainWindow* self, IdCard* id_card) {
	GtkTreeIter iter = {0};
	char* issuer;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	issuer = NULL;
	if (gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->listmodel, &iter)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					if (!gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->listmodel, &iter)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				gtk_tree_model_get ((GtkTreeModel*) self->priv->listmodel, &iter, MAIN_WINDOW_COLUMNS_ISSUER_COL, &issuer, -1);
				if (_vala_strcmp0 (id_card_get_issuer (id_card), issuer) == 0) {
					gtk_list_store_remove (self->priv->listmodel, &iter);
					break;
				}
			}
		}
	}
	_g_free0 (issuer);
}


static void _main_window_details_identity_cb_id_card_widget_details_id (IdCardWidget* _sender, gpointer self) {
	main_window_details_identity_cb (self, _sender);
}


static void _main_window_remove_identity_cb_id_card_widget_remove_id (IdCardWidget* _sender, gpointer self) {
	main_window_remove_identity_cb (self, _sender);
}


static void _main_window_send_identity_cb_id_card_widget_send_id (IdCardWidget* _sender, gpointer self) {
	main_window_send_identity_cb (self, _sender);
}


static void _custom_vbox_receive_expanded_event_id_card_widget_expanded (IdCardWidget* _sender, gpointer self) {
	custom_vbox_receive_expanded_event (self, _sender);
}


static void _main_window_fill_details_id_card_widget_expanded (IdCardWidget* _sender, gpointer self) {
	main_window_fill_details (self, _sender);
}


static void main_window_add_id_card_widget (MainWindow* self, IdCard* id_card) {
	IdCardWidget* id_card_widget;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	id_card_widget = g_object_ref_sink (id_card_widget_new (id_card));
	custom_vbox_add_id_card_widget (self->priv->custom_vbox, id_card_widget);
	g_signal_connect_object (id_card_widget, "details-id", (GCallback) _main_window_details_identity_cb_id_card_widget_details_id, self, 0);
	g_signal_connect_object (id_card_widget, "remove-id", (GCallback) _main_window_remove_identity_cb_id_card_widget_remove_id, self, 0);
	g_signal_connect_object (id_card_widget, "send-id", (GCallback) _main_window_send_identity_cb_id_card_widget_send_id, self, 0);
	g_signal_connect_object (id_card_widget, "expanded", (GCallback) _custom_vbox_receive_expanded_event_id_card_widget_expanded, self->priv->custom_vbox, 0);
	g_signal_connect_object (id_card_widget, "expanded", (GCallback) _main_window_fill_details_id_card_widget_expanded, self, 0);
	_g_object_unref0 (id_card_widget);
}


static void main_window_add_identity (MainWindow* self, AddIdentityDialog* dialog) {
	IdCard* id_card;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dialog != NULL);
	id_card = main_window_get_id_card_data (self, dialog);
	self->priv->identities_manager->id_card_list = g_slist_prepend (self->priv->identities_manager->id_card_list, _g_object_ref0 (id_card));
	identities_manager_store_id_cards (self->priv->identities_manager);
	identities_manager_store_gss_eap_id_file (self->priv->identities_manager, id_card);
	main_window_add_id_card_data (self, id_card);
	main_window_add_id_card_widget (self, id_card);
	_g_object_unref0 (id_card);
}


static void main_window_add_identity_cb (MainWindow* self) {
	AddIdentityDialog* dialog;
	gint _result_;
	g_return_if_fail (self != NULL);
	dialog = g_object_ref_sink (add_identity_dialog_new ());
	_result_ = gtk_dialog_run ((GtkDialog*) dialog);
	switch (_result_) {
		case GTK_RESPONSE_OK:
		{
			main_window_add_identity (self, dialog);
			break;
		}
		default:
		{
			break;
		}
	}
	gtk_object_destroy ((GtkObject*) dialog);
	_g_object_unref0 (dialog);
}


static void main_window_remove_id_card_widget (MainWindow* self, IdCardWidget* id_card_widget) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	main_window_remove_id_card_data (self, id_card_widget_get_id_card (id_card_widget));
	custom_vbox_remove_id_card_widget (self->priv->custom_vbox, id_card_widget);
}


static void main_window_remove_identity (MainWindow* self, IdCardWidget* id_card_widget) {
	IdCard* id_card;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	id_card = _g_object_ref0 (id_card_widget_get_id_card (id_card_widget));
	self->priv->identities_manager->id_card_list = g_slist_remove (self->priv->identities_manager->id_card_list, id_card);
	identities_manager_store_id_cards (self->priv->identities_manager);
	identities_manager_store_gss_eap_id_file (self->priv->identities_manager, NULL);
	main_window_remove_id_card_widget (self, id_card_widget);
	_g_object_unref0 (id_card);
}


static void main_window_redraw_id_card_widgets (MainWindow* self) {
	GtkTreeIter iter = {0};
	IdCard* id_card;
	GList* children;
	g_return_if_fail (self != NULL);
	id_card = NULL;
	children = gtk_container_get_children ((GtkContainer*) self->priv->custom_vbox);
	{
		GList* id_card_widget_collection;
		GList* id_card_widget_it;
		id_card_widget_collection = children;
		for (id_card_widget_it = id_card_widget_collection; id_card_widget_it != NULL; id_card_widget_it = id_card_widget_it->next) {
			GtkWidget* id_card_widget;
			id_card_widget = (GtkWidget*) id_card_widget_it->data;
			{
				gtk_object_destroy ((GtkObject*) id_card_widget);
			}
		}
	}
	if (gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->filter, &iter)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					if (!gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->filter, &iter)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				gtk_tree_model_get ((GtkTreeModel*) self->priv->filter, &iter, MAIN_WINDOW_COLUMNS_IDCARD_COL, &id_card, -1);
				main_window_add_id_card_widget (self, id_card);
			}
		}
	}
	_g_list_free0 (children);
	_g_object_unref0 (id_card);
}


static void main_window_remove_identity_cb (MainWindow* self, IdCardWidget* id_card_widget) {
	IdCard* id_card;
	GtkMessageDialog* dialog;
	gint _result_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	id_card = _g_object_ref0 (id_card_widget_get_id_card (id_card_widget));
	dialog = g_object_ref_sink ((GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_INFO, GTK_BUTTONS_YES_NO, _ ("Are you sure you want to delete %s ID Card?"), id_card_get_issuer (id_card)));
	_result_ = gtk_dialog_run ((GtkDialog*) dialog);
	switch (_result_) {
		case GTK_RESPONSE_YES:
		{
			main_window_remove_identity (self, id_card_widget);
			break;
		}
		default:
		{
			break;
		}
	}
	gtk_object_destroy ((GtkObject*) dialog);
	_g_object_unref0 (dialog);
	_g_object_unref0 (id_card);
}


void main_window_select_identity (MainWindow* self, IdentityRequest* request) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (request != NULL);
	g_queue_push_tail (self->priv->request_queue, _g_object_ref0 (request));
	gtk_widget_show ((GtkWidget*) self);
}


void main_window_send_identity_cb (MainWindow* self, IdCardWidget* id_card_widget) {
	IdCardWidget* _tmp0_;
	IdentityRequest* request;
	IdCard* identity;
	gboolean reset_password;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	g_return_if_fail (self->priv->request_queue->length > 0);
	self->selected_id_card_widget = (_tmp0_ = _g_object_ref0 (id_card_widget), _g_object_unref0 (self->selected_id_card_widget), _tmp0_);
	request = (IdentityRequest*) g_queue_pop_head (self->priv->request_queue);
	identity = _g_object_ref0 (id_card_widget_get_id_card (id_card_widget));
	reset_password = FALSE;
	if (id_card_get_password (identity) == NULL) {
		AddPasswordDialog* dialog;
		gint _result_;
		dialog = g_object_ref_sink (add_password_dialog_new ());
		_result_ = gtk_dialog_run ((GtkDialog*) dialog);
		switch (_result_) {
			case GTK_RESPONSE_OK:
			{
				id_card_set_password (identity, add_password_dialog_get_password (dialog));
				reset_password = !add_password_dialog_get_remember (dialog);
				break;
			}
			default:
			{
				IdCard* _tmp1_;
				identity = (_tmp1_ = NULL, _g_object_unref0 (identity), _tmp1_);
				break;
			}
		}
		gtk_object_destroy ((GtkObject*) dialog);
		_g_object_unref0 (dialog);
	}
	if (g_queue_is_empty (self->priv->request_queue)) {
		gtk_widget_hide ((GtkWidget*) self);
	}
	identity_request_return_identity (request, identity);
	if (reset_password) {
		id_card_set_password (identity, NULL);
	}
	_g_object_unref0 (identity);
	_g_object_unref0 (request);
}


static void main_window_label_make_bold (MainWindow* self, GtkLabel* label) {
	PangoFontDescription* font_desc;
	g_return_if_fail (self != NULL);
	g_return_if_fail (label != NULL);
	font_desc = pango_font_description_new ();
	pango_font_description_set_weight (font_desc, PANGO_WEIGHT_BOLD);
	gtk_widget_modify_font ((GtkWidget*) label, font_desc);
	_pango_font_description_free0 (font_desc);
}


static void main_window_fill_services_vbox (MainWindow* self, IdCard* id_card) {
	gint i;
	gint _tmp0_;
	gint n_columns;
	GtkTable* services_table;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	i = 0;
	n_columns = _tmp0_;
	services_table = g_object_ref_sink ((GtkTable*) gtk_table_new ((guint) n_columns, (guint) 2, FALSE));
	gtk_table_set_col_spacings (services_table, (guint) 10);
	gtk_table_set_row_spacings (services_table, (guint) 10);
	gtk_container_add ((GtkContainer*) self->priv->services_internal_vbox, (GtkWidget*) services_table);
	{
		gint _tmp1_;
		char** service_collection;
		int service_collection_length1;
		int service_it;
		service_collection = id_card_get_services (id_card, &_tmp1_);
		service_collection_length1 = _tmp1_;
		for (service_it = 0; service_it < _tmp1_; service_it = service_it + 1) {
			char* service;
			service = g_strdup (service_collection[service_it]);
			{
				GtkLabel* label;
				GtkButton* remove_button;
				label = g_object_ref_sink ((GtkLabel*) gtk_label_new (service));
				gtk_misc_set_alignment ((GtkMisc*) label, (float) 0, (float) 0.5);
				remove_button = g_object_ref_sink ((GtkButton*) gtk_button_new_from_stock (GTK_STOCK_REMOVE));
				gtk_table_attach_defaults (services_table, (GtkWidget*) label, (guint) 0, (guint) 1, (guint) i, (guint) (i + 1));
				gtk_table_attach_defaults (services_table, (GtkWidget*) remove_button, (guint) 1, (guint) 2, (guint) i, (guint) (i + 1));
				i++;
				_g_object_unref0 (remove_button);
				_g_object_unref0 (label);
				_g_free0 (service);
			}
		}
	}
	gtk_widget_show_all ((GtkWidget*) self->priv->services_internal_vbox);
	_g_object_unref0 (services_table);
}


static void main_window_on_about_action (MainWindow* self) {
	gint authors_length1;
	gint _authors_size_;
	char** _tmp1_;
	char** _tmp0_ = NULL;
	char** authors;
	char* copyright;
	char* license;
	g_return_if_fail (self != NULL);
	authors = (_tmp1_ = (_tmp0_ = g_new0 (char*, 3 + 1), _tmp0_[0] = g_strdup ("Javier Jard√≥n <jjardon@codethink.co.uk>"), _tmp0_[1] = g_strdup ("Sam Thursfield <samthursfield@codethink.co.uk>"), _tmp0_[2] = NULL, _tmp0_), authors_length1 = 3, _authors_size_ = authors_length1, _tmp1_);
	copyright = g_strdup ("Copyright 2011 JANET");
	license = g_strdup ("\n" \
"Copyright (c) 2011, JANET(UK)\n" \
"All rights reserved.\n" \
"\n" \
"Redistribution and use in source and binary forms, with or without\n" \
"modification, are permitted provided that the following conditions\n" \
"are met:\n" \
"\n" \
"1. Redistributions of source code must retain the above copyright\n" \
"   notice, this list of conditions and the following disclaimer.\n" \
"\n" \
"2. Redistributions in binary form must reproduce the above copyright\n" \
"   notice, this list of conditions and the following disclaimer in the" \
"\n" \
"   documentation and/or other materials provided with the distribution" \
".\n" \
"\n" \
"3. Neither the name of JANET(UK) nor the names of its contributors\n" \
"   may be used to endorse or promote products derived from this softwa" \
"re\n" \
"   without specific prior written permission.\n" \
"\n" \
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\" \
"\"AS IS\\\"\n" \
"AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, " \
"THE\n" \
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PUR" \
"POSE\n" \
"ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS" \
" BE LIABLE\n" \
"FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUEN" \
"TIAL\n" \
"DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOOD" \
"S\n" \
"OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n" \
"HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, ST" \
"RICT\n" \
"LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY " \
"WAY\n" \
"OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF" \
"\n" \
"SUCH DAMAGE.\n");
	gtk_show_about_dialog ((GtkWindow*) self, "comments", _ ("Moonshot project UI"), "copyright", copyright, "website", "http://www.project-moonshot.org/", "license", license, "website-label", _ ("Visit the Moonshot project web site"), "authors", authors, "translator-credits", _ ("translator-credits"), NULL, NULL);
	_g_free0 (license);
	_g_free0 (copyright);
	authors = (_vala_array_free (authors, authors_length1, (GDestroyNotify) g_free), NULL);
}


static void _vala_array_add1 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _main_window_add_identity_cb_gtk_action_callback (GtkAction* action, gpointer self) {
	main_window_add_identity_cb (self);
}


static void _vala_array_add2 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _gtk_main_quit_gtk_action_callback (GtkAction* action, gpointer self) {
	gtk_main_quit ();
}


static void _vala_array_add3 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _vala_array_add4 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _main_window_on_about_action_gtk_action_callback (GtkAction* action, gpointer self) {
	main_window_on_about_action (self);
}


static void _vala_array_add5 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static GtkActionEntry* main_window_create_actions (MainWindow* self, int* result_length1) {
	GtkActionEntry* result = NULL;
	gint actions_length1;
	gint _actions_size_;
	GtkActionEntry* _tmp0_;
	GtkActionEntry* actions;
	GtkActionEntry _tmp1_ = {0};
	GtkActionEntry filemenu;
	GtkActionEntry _tmp2_ = {0};
	GtkActionEntry add;
	GtkActionEntry _tmp3_ = {0};
	GtkActionEntry quit;
	GtkActionEntry _tmp4_ = {0};
	GtkActionEntry helpmenu;
	GtkActionEntry _tmp5_ = {0};
	GtkActionEntry about;
	GtkActionEntry* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	actions = (_tmp0_ = g_new0 (GtkActionEntry, 0), actions_length1 = 0, _actions_size_ = actions_length1, _tmp0_);
	filemenu = (_tmp1_.name = "FileMenuAction", _tmp1_.stock_id = NULL, _tmp1_.label = N_ ("_File"), _tmp1_.accelerator = NULL, _tmp1_.tooltip = NULL, _tmp1_.callback = (GCallback) NULL, _tmp1_);
	_vala_array_add1 (&actions, &actions_length1, &_actions_size_, &filemenu);
	add = (_tmp2_.name = "AddIdCardAction", _tmp2_.stock_id = GTK_STOCK_ADD, _tmp2_.label = N_ ("Add ID Card"), _tmp2_.accelerator = NULL, _tmp2_.tooltip = N_ ("Add a new ID Card"), _tmp2_.callback = (GCallback) _main_window_add_identity_cb_gtk_action_callback, _tmp2_);
	_vala_array_add2 (&actions, &actions_length1, &_actions_size_, &add);
	quit = (_tmp3_.name = "QuitAction", _tmp3_.stock_id = GTK_STOCK_QUIT, _tmp3_.label = N_ ("Quit"), _tmp3_.accelerator = "<control>Q", _tmp3_.tooltip = N_ ("Quit the application"), _tmp3_.callback = (GCallback) _gtk_main_quit_gtk_action_callback, _tmp3_);
	_vala_array_add3 (&actions, &actions_length1, &_actions_size_, &quit);
	helpmenu = (_tmp4_.name = "HelpMenuAction", _tmp4_.stock_id = NULL, _tmp4_.label = N_ ("_Help"), _tmp4_.accelerator = NULL, _tmp4_.tooltip = NULL, _tmp4_.callback = (GCallback) NULL, _tmp4_);
	_vala_array_add4 (&actions, &actions_length1, &_actions_size_, &helpmenu);
	about = (_tmp5_.name = "AboutAction", _tmp5_.stock_id = GTK_STOCK_ABOUT, _tmp5_.label = N_ ("About"), _tmp5_.accelerator = NULL, _tmp5_.tooltip = N_ ("About this application"), _tmp5_.callback = (GCallback) _main_window_on_about_action_gtk_action_callback, _tmp5_);
	_vala_array_add5 (&actions, &actions_length1, &_actions_size_, &about);
	result = (_tmp6_ = actions, *result_length1 = actions_length1, _tmp6_);
	return result;
	actions = (g_free (actions), NULL);
}


static void main_window_create_ui_manager (MainWindow* self) {
	GtkActionGroup* action_group;
	gint _tmp0_;
	GtkActionEntry* _tmp1_;
	gint _tmp1__length1;
	GtkActionEntry* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	action_group = gtk_action_group_new ("GeneralActionGroup");
	_tmp2_ = (_tmp1_ = main_window_create_actions (self, &_tmp0_), _tmp1__length1 = _tmp0_, _tmp1_);
	gtk_action_group_add_actions (action_group, _tmp2_, _tmp0_, self);
	_tmp1_ = (g_free (_tmp1_), NULL);
	gtk_ui_manager_insert_action_group (self->priv->ui_manager, action_group, 0);
	{
		gtk_ui_manager_add_ui_from_string (self->priv->ui_manager, MAIN_WINDOW_layout, (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch5_g_error;
		}
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "%s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally5:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (action_group);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	gtk_ui_manager_ensure_update (self->priv->ui_manager);
	_g_object_unref0 (action_group);
}


static void _main_window_search_entry_icon_press_cb_gtk_entry_icon_press (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self) {
	main_window_search_entry_icon_press_cb (self, p0, p1);
}


static void _main_window_search_entry_text_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	main_window_search_entry_text_changed_cb (self);
}


static gboolean _main_window_search_entry_key_press_event_cb_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = main_window_search_entry_key_press_event_cb (self, event);
	return result;
}


static void main_window_build_ui (MainWindow* self) {
	GtkEntry* _tmp0_;
	GdkPixbuf* _tmp1_;
	GdkPixbuf* _tmp2_;
	CustomVBox* _tmp3_;
	GtkViewport* viewport;
	GtkScrolledWindow* scroll;
	GtkVBox* vbox_left;
	GtkLabel* login_vbox_title;
	GtkLabel* username_label;
	GtkEntry* _tmp4_;
	GtkLabel* password_label;
	GtkEntry* _tmp5_;
	GtkCheckButton* remember_checkbutton;
	GtkTable* login_table;
	GtkAlignment* login_vbox_alignment;
	GtkVBox* login_vbox;
	GtkLabel* services_vbox_title;
	GtkAlignment* services_vbox_alignment;
	GtkVBox* _tmp6_;
	GtkVBox* services_vbox;
	GtkVBox* _tmp7_;
	GtkHBox* hbox;
	GtkVBox* main_vbox;
	GtkWidget* menubar;
	g_return_if_fail (self != NULL);
	main_window_create_ui_manager (self);
	self->priv->search_entry = (_tmp0_ = g_object_ref_sink ((GtkEntry*) gtk_entry_new ()), _g_object_unref0 (self->priv->search_entry), _tmp0_);
	main_window_set_atk_name_description (self, (GtkWidget*) self->priv->search_entry, _ ("Search entry"), _ ("Search for a specific ID Card"));
	gtk_entry_set_icon_from_pixbuf (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, _tmp1_ = find_icon_sized ("edit-find-symbolic", GTK_ICON_SIZE_MENU));
	_g_object_unref0 (_tmp1_);
	gtk_entry_set_icon_tooltip_text (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, _ ("Search identity or service"));
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, FALSE);
	gtk_entry_set_icon_from_pixbuf (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, _tmp2_ = find_icon_sized ("edit-clear-symbolic", GTK_ICON_SIZE_MENU));
	_g_object_unref0 (_tmp2_);
	gtk_entry_set_icon_tooltip_text (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, _ ("Clear the current search"));
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, FALSE);
	g_signal_connect_object (self->priv->search_entry, "icon-press", (GCallback) _main_window_search_entry_icon_press_cb_gtk_entry_icon_press, self, 0);
	g_signal_connect_object ((GObject*) self->priv->search_entry, "notify::text", (GCallback) _main_window_search_entry_text_changed_cb_g_object_notify, self, 0);
	g_signal_connect_object ((GtkWidget*) self->priv->search_entry, "key-press-event", (GCallback) _main_window_search_entry_key_press_event_cb_gtk_widget_key_press_event, self, 0);
	self->priv->custom_vbox = (_tmp3_ = g_object_ref_sink (custom_vbox_new (FALSE, 6)), _g_object_unref0 (self->priv->custom_vbox), _tmp3_);
	viewport = g_object_ref_sink ((GtkViewport*) gtk_viewport_new (NULL, NULL));
	gtk_container_set_border_width ((GtkContainer*) viewport, (guint) 6);
	gtk_viewport_set_shadow_type (viewport, GTK_SHADOW_NONE);
	gtk_container_add ((GtkContainer*) viewport, (GtkWidget*) self->priv->custom_vbox);
	scroll = g_object_ref_sink ((GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL));
	gtk_scrolled_window_set_policy (scroll, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type (scroll, GTK_SHADOW_IN);
	gtk_scrolled_window_add_with_viewport (scroll, (GtkWidget*) viewport);
	vbox_left = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	gtk_box_pack_start ((GtkBox*) vbox_left, (GtkWidget*) self->priv->search_entry, FALSE, FALSE, (guint) 6);
	gtk_box_pack_start ((GtkBox*) vbox_left, (GtkWidget*) scroll, TRUE, TRUE, (guint) 0);
	gtk_widget_set_size_request ((GtkWidget*) vbox_left, MAIN_WINDOW_WINDOW_WIDTH, 0);
	login_vbox_title = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Login: ")));
	main_window_label_make_bold (self, login_vbox_title);
	gtk_misc_set_alignment ((GtkMisc*) login_vbox_title, (float) 0, (float) 0.5);
	username_label = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Username:")));
	gtk_misc_set_alignment ((GtkMisc*) username_label, (float) 1, (float) 0.5);
	self->priv->username_entry = (_tmp4_ = g_object_ref_sink ((GtkEntry*) gtk_entry_new ()), _g_object_unref0 (self->priv->username_entry), _tmp4_);
	password_label = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Password:")));
	gtk_misc_set_alignment ((GtkMisc*) password_label, (float) 1, (float) 0.5);
	self->priv->password_entry = (_tmp5_ = g_object_ref_sink ((GtkEntry*) gtk_entry_new ()), _g_object_unref0 (self->priv->password_entry), _tmp5_);
	gtk_entry_set_invisible_char (self->priv->password_entry, (gunichar) '*');
	gtk_entry_set_visibility (self->priv->password_entry, FALSE);
	remember_checkbutton = g_object_ref_sink ((GtkCheckButton*) gtk_check_button_new_with_label (_ ("Remember password")));
	login_table = g_object_ref_sink ((GtkTable*) gtk_table_new ((guint) 3, (guint) 3, FALSE));
	gtk_table_set_col_spacings (login_table, (guint) 10);
	gtk_table_set_row_spacings (login_table, (guint) 10);
	gtk_table_attach_defaults (login_table, (GtkWidget*) username_label, (guint) 0, (guint) 1, (guint) 0, (guint) 1);
	gtk_table_attach_defaults (login_table, (GtkWidget*) self->priv->username_entry, (guint) 1, (guint) 2, (guint) 0, (guint) 1);
	gtk_table_attach_defaults (login_table, (GtkWidget*) password_label, (guint) 0, (guint) 1, (guint) 1, (guint) 2);
	gtk_table_attach_defaults (login_table, (GtkWidget*) self->priv->password_entry, (guint) 1, (guint) 2, (guint) 1, (guint) 2);
	gtk_table_attach_defaults (login_table, (GtkWidget*) remember_checkbutton, (guint) 1, (guint) 2, (guint) 2, (guint) 3);
	login_vbox_alignment = g_object_ref_sink ((GtkAlignment*) gtk_alignment_new ((float) 0, (float) 0, (float) 0, (float) 0));
	gtk_alignment_set_padding (login_vbox_alignment, (guint) 0, (guint) 0, (guint) 12, (guint) 0);
	gtk_container_add ((GtkContainer*) login_vbox_alignment, (GtkWidget*) login_table);
	login_vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 6));
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) login_vbox_title, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) login_vbox_alignment, FALSE, TRUE, (guint) 0);
	services_vbox_title = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Services:")));
	main_window_label_make_bold (self, services_vbox_title);
	gtk_misc_set_alignment ((GtkMisc*) services_vbox_title, (float) 0, (float) 0.5);
	services_vbox_alignment = g_object_ref_sink ((GtkAlignment*) gtk_alignment_new ((float) 0, (float) 0, (float) 0, (float) 0));
	gtk_alignment_set_padding (services_vbox_alignment, (guint) 0, (guint) 0, (guint) 12, (guint) 0);
	self->priv->services_internal_vbox = (_tmp6_ = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (TRUE, 6)), _g_object_unref0 (self->priv->services_internal_vbox), _tmp6_);
	gtk_container_add ((GtkContainer*) services_vbox_alignment, (GtkWidget*) self->priv->services_internal_vbox);
	services_vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 6));
	gtk_box_pack_start ((GtkBox*) services_vbox, (GtkWidget*) services_vbox_title, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) services_vbox, (GtkWidget*) services_vbox_alignment, FALSE, TRUE, (guint) 0);
	self->priv->vbox_rigth = (_tmp7_ = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 18)), _g_object_unref0 (self->priv->vbox_rigth), _tmp7_);
	gtk_box_pack_start ((GtkBox*) self->priv->vbox_rigth, (GtkWidget*) login_vbox, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) self->priv->vbox_rigth, (GtkWidget*) services_vbox, FALSE, TRUE, (guint) 0);
	hbox = g_object_ref_sink ((GtkHBox*) gtk_hbox_new (FALSE, 12));
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) vbox_left, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) self->priv->vbox_rigth, FALSE, FALSE, (guint) 0);
	main_vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	gtk_container_set_border_width ((GtkContainer*) main_vbox, (guint) 12);
	menubar = _g_object_ref0 (gtk_ui_manager_get_widget (self->priv->ui_manager, "/MenuBar"));
	gtk_box_pack_start ((GtkBox*) main_vbox, menubar, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) main_vbox, (GtkWidget*) hbox, TRUE, TRUE, (guint) 0);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) main_vbox);
	gtk_widget_show_all ((GtkWidget*) main_vbox);
	gtk_widget_hide ((GtkWidget*) self->priv->vbox_rigth);
	_g_object_unref0 (menubar);
	_g_object_unref0 (main_vbox);
	_g_object_unref0 (hbox);
	_g_object_unref0 (services_vbox);
	_g_object_unref0 (services_vbox_alignment);
	_g_object_unref0 (services_vbox_title);
	_g_object_unref0 (login_vbox);
	_g_object_unref0 (login_vbox_alignment);
	_g_object_unref0 (login_table);
	_g_object_unref0 (remember_checkbutton);
	_g_object_unref0 (password_label);
	_g_object_unref0 (username_label);
	_g_object_unref0 (login_vbox_title);
	_g_object_unref0 (vbox_left);
	_g_object_unref0 (scroll);
	_g_object_unref0 (viewport);
}


static void main_window_set_atk_name_description (MainWindow* self, GtkWidget* widget, const char* name, const char* description) {
	AtkObject* atk_widget;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (description != NULL);
	atk_widget = _g_object_ref0 (gtk_widget_get_accessible (widget));
	atk_object_set_name (atk_widget, name);
	atk_object_set_description (atk_widget, description);
	_g_object_unref0 (atk_widget);
}


static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self) {
	gtk_main_quit ();
}


static void main_window_connect_signals (MainWindow* self) {
	g_return_if_fail (self != NULL);
	g_signal_connect ((GtkObject*) self, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
}


static guint _dynamic_request_name0 (DBusGProxy* self, const char* param1, guint param2, GError** error) {
	guint result;
	dbus_g_proxy_call (self, "RequestName", error, G_TYPE_STRING, param1, G_TYPE_UINT, param2, G_TYPE_INVALID, G_TYPE_UINT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0U;
	}
	return result;
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}


static void main_window_init_ipc_server (MainWindow* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		DBusGConnection* conn;
		DBusGProxy* bus;
		guint reply;
		MoonshotServer* _tmp0_;
		conn = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == DBUS_GERROR) {
				goto __catch6_dbus_gerror;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		bus = dbus_g_proxy_new_for_name (conn, "org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus");
		reply = _dynamic_request_name0 (bus, "org.janet.Moonshot", (guint) 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (bus);
			_dbus_g_connection_unref0 (conn);
			if (_inner_error_->domain == DBUS_GERROR) {
				goto __catch6_dbus_gerror;
			}
			goto __finally6;
		}
		g_assert (reply == DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER);
		self->priv->ipc_server = (_tmp0_ = moonshot_server_new ((GtkWindow*) self), _g_object_unref0 (self->priv->ipc_server), _tmp0_);
		_vala_dbus_register_object (dbus_g_connection_get_connection (conn), "/org/janet/moonshot", (GObject*) self->priv->ipc_server);
		_g_object_unref0 (bus);
		_dbus_g_connection_unref0 (conn);
	}
	goto __finally6;
	__catch6_dbus_gerror:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "%s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally6:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


gint main_window_main (char** args, int args_length1) {
	gint result = 0;
	MainWindow* window;
	gtk_init (&args_length1, &args);
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	window = g_object_ref_sink (main_window_new ());
	gtk_widget_show ((GtkWidget*) window);
	gtk_main ();
	result = 0;
	_g_object_unref0 (window);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return main_window_main (argv, argc);
}


static void main_window_class_init (MainWindowClass * klass) {
	main_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MainWindowPrivate));
	G_OBJECT_CLASS (klass)->finalize = main_window_finalize;
}


static void main_window_instance_init (MainWindow * self) {
	self->priv = MAIN_WINDOW_GET_PRIVATE (self);
	self->priv->ui_manager = gtk_ui_manager_new ();
}


static void main_window_finalize (GObject* obj) {
	MainWindow * self;
	self = MAIN_WINDOW (obj);
	_g_object_unref0 (self->priv->ui_manager);
	_g_object_unref0 (self->priv->search_entry);
	_g_object_unref0 (self->priv->vbox_rigth);
	_g_object_unref0 (self->priv->custom_vbox);
	_g_object_unref0 (self->priv->services_internal_vbox);
	_g_object_unref0 (self->priv->username_entry);
	_g_object_unref0 (self->priv->password_entry);
	_g_object_unref0 (self->priv->listmodel);
	_g_object_unref0 (self->priv->filter);
	_g_object_unref0 (self->priv->identities_manager);
	_g_object_unref0 (self->priv->ipc_server);
	_g_object_unref0 (self->selected_id_card_widget);
	_g_queue_free0 (self->priv->request_queue);
	G_OBJECT_CLASS (main_window_parent_class)->finalize (obj);
}


GType main_window_get_type (void) {
	static volatile gsize main_window_type_id__volatile = 0;
	if (g_once_init_enter (&main_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MainWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) main_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MainWindow), 0, (GInstanceInitFunc) main_window_instance_init, NULL };
		GType main_window_type_id;
		main_window_type_id = g_type_register_static (GTK_TYPE_WINDOW, "MainWindow", &g_define_type_info, 0);
		g_once_init_leave (&main_window_type_id__volatile, main_window_type_id);
	}
	return main_window_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




